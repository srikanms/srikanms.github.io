<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mind Map Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #ffffff;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        .toolbar {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            display: flex;
            gap: 10px;
        }

        .toolbar button {
            padding: 10px 16px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background: #ffffff;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            color: #4a5568;
        }

        .toolbar button:hover {
            background: #f7fafc;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border-color: #cbd5e0;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            cursor: grab;
            background: #ffffff;
        }

        #canvas-container:active {
            cursor: grabbing;
        }

        #mindmap-inner {
            position: absolute;
            top: 0; left: 0;
            will-change: transform;
            width: 100%;
            height: 100%;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: visible;
        }

        .node {
            position: absolute;
            min-width: 120px;
            max-width: 200px;
            min-height: 40px;
            background: #ffffff;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: border-color 0.3s ease, background-color 0.3s ease, box-shadow 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            font-size: 14px;
            font-weight: 500;
            color: #2d3748;
            padding: 8px 16px;
            text-align: center;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            z-index: 10;
            white-space: pre-wrap;
            line-height: 1.3;
        }

        .node:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border-color: #cbd5e0;
        }

        .node.selected {
            border-color: #4299e1;
            background: #ebf8ff;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.3);
        }

        .node.editing {
            background: #ffffff;
            border-color: #4299e1;
        }

        .node input {
            border: none;
            outline: none;
            background: transparent;
            font-size: 14px;
            font-weight: 500;
            color: #2d3748;
            text-align: center;
            width: 100%;
            min-width: 100px;
        }

        .expand-btn {
            position: absolute;
            right: -12px;
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 24px;
            border: 1px solid #e2e8f0;
            border-radius: 50%;
            background: #4299e1;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
            z-index: 20;
        }

        .expand-btn:hover {
            background: #3182ce;
            transform: translateY(-50%) scale(1.1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .edge {
            position: absolute;
            pointer-events: none;
            z-index: 1;
        }

        .instructions {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(45, 55, 72, 0.95);
            color: white;
            border-radius: 8px;
            font-size: 12px;
            max-width: 320px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .instructions.collapsed {
            cursor: pointer;
            padding: 10px 15px;
        }

        .instructions.expanded {
            padding: 15px;
        }

        .instructions-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .instructions.collapsed .instructions-header {
            margin-bottom: 0;
        }

        .instructions-content {
            display: block;
        }

        .instructions.collapsed .instructions-content {
            display: none;
        }

        .instructions-toggle {
            font-size: 14px;
            opacity: 0.8;
            transition: transform 0.3s ease;
        }

        .instructions.collapsed .instructions-toggle {
            transform: rotate(-90deg);
        }

        .instructions-hint {
            font-size: 11px;
            opacity: 0.7;
            margin-left: 8px;
        }

        .instructions.expanded .instructions-hint {
            display: none;
        }

        .instructions div {
            margin-bottom: 5px;
        }

        .delete-confirm {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            min-width: 300px;
            text-align: center;
        }

        .delete-confirm h3 {
            margin: 0 0 10px 0;
            color: #2d3748;
        }

        .delete-confirm p {
            margin: 0 0 20px 0;
            color: #718096;
            font-size: 14px;
        }

        .delete-confirm-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .delete-confirm button {
            padding: 8px 20px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .delete-confirm .confirm-btn {
            background: #e53e3e;
            color: white;
            border-color: #e53e3e;
        }

        .delete-confirm .confirm-btn:hover {
            background: #c53030;
            border-color: #c53030;
        }

        .delete-confirm .cancel-btn {
            background: white;
            color: #4a5568;
        }

        .delete-confirm .cancel-btn:hover {
            background: #f7fafc;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            z-index: 1999;
        }        .hidden {
            display: none !important;
        }

        /* Note feature styles */
        .note-indicator {
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 16px;
            height: 16px;
            background: #f6ad55;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: white;
            z-index: 25;
            transition: all 0.3s ease;
        }

        .note-indicator:hover {
            transform: translateX(-50%) scale(1.2);
            background: #ed8936;
        }

        .note-indicator.has-note {
            background: #38a169;
        }

        .note-indicator.has-note:hover {
            background: #2f855a;
        }

        .note-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
            z-index: 2001;
            min-width: 400px;
            max-width: 600px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }

        .note-modal-header {
            padding: 20px 20px 10px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .note-modal-header h3 {
            margin: 0;
            color: #2d3748;
            font-size: 18px;
        }

        .note-modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #718096;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .note-modal-close:hover {
            background: #f7fafc;
            color: #2d3748;
        }

        .note-modal-body {
            padding: 20px;
            flex: 1;
            overflow-y: auto;
        }

        .note-textarea {
            width: 100%;
            min-height: 200px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 12px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px;
            line-height: 1.5;
            resize: vertical;
            outline: none;
            transition: border-color 0.3s ease;
        }

        .note-textarea:focus {
            border-color: #4299e1;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.1);
        }

        .note-modal-footer {
            padding: 15px 20px;
            border-top: 1px solid #e2e8f0;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .note-modal-footer button {
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
            border: 1px solid #e2e8f0;
        }

        .note-save-btn {
            background: #4299e1;
            color: white;
            border-color: #4299e1;
        }

        .note-save-btn:hover {
            background: #3182ce;
            border-color: #3182ce;
        }

        .note-cancel-btn {
            background: white;
            color: #4a5568;
        }

        .note-cancel-btn:hover {
            background: #f7fafc;
        }

        .note-delete-btn {
            background: #e53e3e;
            color: white;
            border-color: #e53e3e;
        }

        .note-delete-btn:hover {
            background: #c53030;
            border-color: #c53030;
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <button onclick="saveMindMapAsMarkdown()">📝 Save Markdown</button>
        <button onclick="loadMindMapFromMarkdown()">📄 Load Markdown</button>
    </div>

    <div id="canvas-container">
        <div id="mindmap-inner">
            <svg id="canvas" width="100%" height="100%">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                            refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#4299e1" opacity="0.8"/>
                    </marker>
                </defs>
            </svg>
        </div>
    </div>

    <div class="instructions collapsed" id="instructions">
        <div class="instructions-header" onclick="toggleInstructions()">
            <div>
                <strong>Controls</strong>
                <span class="instructions-hint">(click to expand)</span>
            </div>
            <span class="instructions-toggle">▼</span>
        </div>        <div class="instructions-content">
            <div>Click/Enter: Create first node</div>
            <div>Enter: Edit selected node</div>
            <div>N: Add/edit note for selected node</div>
            <div>Delete: Delete node</div>
            <div>Ctrl+→: Add child</div>
            <div>Ctrl+↓: Add sibling below</div>
            <div>Ctrl+↑: Add sibling above</div>
            <div>Ctrl+←: Progressive collapse</div>
            <div>Arrow keys: Navigate</div>
            <div>Mouse wheel: Zoom</div>
            <div>Click & drag canvas: Pan</div>
        </div>
    </div>

    <div id="overlay" class="overlay hidden"></div>
    <div id="delete-confirm" class="delete-confirm hidden">
        <h3>Delete Node?</h3>
        <p>This node has <span id="child-count"></span> child node(s). Delete the entire branch?</p>
        <div class="delete-confirm-buttons">
            <button class="cancel-btn" onclick="cancelDelete()">Cancel</button>
            <button class="confirm-btn" onclick="confirmDelete()">Delete</button>
        </div>
    </div>

    <!-- Note modal -->
    <div id="note-modal" class="note-modal hidden">
        <div class="note-modal-header">
            <h3>Node Note</h3>
            <button class="note-modal-close" onclick="closeNoteModal()">×</button>
        </div>
        <div class="note-modal-body">
            <textarea id="note-textarea" class="note-textarea" placeholder="Add your note here..."></textarea>
        </div>
        <div class="note-modal-footer">
            <button class="note-delete-btn" onclick="deleteNote()" id="note-delete-btn" style="display: none;">Delete Note</button>
            <button class="note-cancel-btn" onclick="closeNoteModal()">Cancel</button>
            <button class="note-save-btn" onclick="saveNote()">Save Note</button>
        </div>
    </div>

    <script>        // --- State ---
        let nodes = [];
        let selectedNode = null;
        let nextId = 1;
        let pan = { x: 0, y: 0 };
        let zoom = 1;
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        let dragStart = { x: 0, y: 0 };
        let editingNode = null;
        let renderScheduled = false;
        let nodeToDelete = null;
        let currentNoteNode = null; // For note editing

        const canvasContainer = document.getElementById('canvas-container');
        const mindmapInner = document.getElementById('mindmap-inner');
        const canvas = document.getElementById('canvas');

        // --- Pan/Zoom ---
        function applyTransform() {
            mindmapInner.style.transform = `translate(${pan.x}px,${pan.y}px) scale(${zoom})`;
        }
        applyTransform();

        canvasContainer.addEventListener('mousedown', e => {
            if (e.button !== 0) return;
            // Check if clicking on empty space
            if (e.target === canvasContainer || e.target === mindmapInner || e.target === canvas) {
                if (nodes.length === 0) {
                    createFirstNode(e);
                    return;
                }
                isPanning = true;
                panStart = { x: e.clientX, y: e.clientY };
                dragStart = { x: pan.x, y: pan.y };
                canvasContainer.style.cursor = 'grabbing';
            }
        });
        
        window.addEventListener('mousemove', e => {
            if (isPanning) {
                pan.x = dragStart.x + (e.clientX - panStart.x);
                pan.y = dragStart.y + (e.clientY - panStart.y);
                applyTransform();
            }
        });
        
        window.addEventListener('mouseup', e => {
            isPanning = false;
            canvasContainer.style.cursor = 'grab';
        });
        
        canvasContainer.addEventListener('wheel', e => {
            e.preventDefault();
            const scale = Math.exp(-e.deltaY * 0.001);
            const rect = mindmapInner.getBoundingClientRect();
            const cx = (e.clientX - rect.left) / zoom;
            const cy = (e.clientY - rect.top) / zoom;
            zoom *= scale;
            zoom = Math.max(0.2, Math.min(zoom, 2.5));
            pan.x -= (cx * (scale - 1)) * zoom;
            pan.y -= (cy * (scale - 1)) * zoom;
            applyTransform();
        }, { passive: false });        // --- Node creation ---
        function createFirstNode(e) {
            // Position the first node on the left side with nice margin (200px from left edge)
            const leftMargin = 200;
            const x = (leftMargin - pan.x) / zoom;
            const y = (window.innerHeight / 2 - pan.y) / zoom;
            const node = createNode('New Idea', x, y, null);
            scheduleRender();
            // Wait for render to complete before selecting and editing
            setTimeout(() => {
                selectNode(node);
                startEditing(node);
            }, 50);
        }function createNode(text, x, y, parent) {
            const node = {
                id: nextId++,
                text,
                x, y,
                parent,
                children: [],
                collapsed: false,
                element: null,
                expandBtn: null,
                note: '' // Add note property
            };
            if (parent) parent.children.push(node);
            nodes.push(node);
            return node;
        }

        // --- Performance optimized rendering ---
        function scheduleRender() {
            if (!renderScheduled) {
                renderScheduled = true;
                requestAnimationFrame(() => {
                    render();
                    renderScheduled = false;
                });
            }
        }

        function render() {
            // Remove all node elements
            mindmapInner.querySelectorAll('.node').forEach(el => el.remove());
            // Clear canvas edges
            while (canvas.firstChild) {
                canvas.removeChild(canvas.firstChild);
            }
            // Re-add defs
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            marker.setAttribute('id', 'arrowhead');
            marker.setAttribute('markerWidth', '10');
            marker.setAttribute('markerHeight', '7');
            marker.setAttribute('refX', '9');
            marker.setAttribute('refY', '3.5');
            marker.setAttribute('orient', 'auto');
            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
            polygon.setAttribute('fill', '#4299e1');
            polygon.setAttribute('opacity', '0.8');
            marker.appendChild(polygon);
            defs.appendChild(marker);
            canvas.appendChild(defs);

            // Render nodes recursively
            nodes.forEach(node => {
                if (!node.parent) renderSubtree(node);
            });
            
            // Render edges after all nodes are rendered
            setTimeout(() => {
                nodes.forEach(node => {
                    if (node.parent && !isNodeHidden(node)) {
                        drawEdge(node.parent, node);
                    }
                });
            }, 0);
        }

        function isNodeHidden(node) {
            if (!node.parent) return false;
            if (node.parent.collapsed) return true;
            return isNodeHidden(node.parent);
        }

        function renderSubtree(node) {
            // Node element
            const nodeEl = document.createElement('div');
            nodeEl.className = 'node';
            nodeEl.style.left = node.x + 'px';
            nodeEl.style.top = node.y + 'px';
            
            // Better text handling
            const textContent = node.text || 'New Node';
            nodeEl.textContent = textContent;
            
            // Adjust width based on text length
            const textLength = textContent.length;
            if (textLength > 15) {
                nodeEl.style.width = Math.min(200, Math.max(120, textLength * 8)) + 'px';
            }
            
            if (selectedNode === node) nodeEl.classList.add('selected');
            if (editingNode === node) nodeEl.classList.add('editing');
            nodeEl.onclick = e => {
                e.stopPropagation();
                selectNode(node);
            };
              // Expand/collapse button
            if (node.children.length > 0) {
                const btn = document.createElement('button');
                btn.className = 'expand-btn';
                btn.textContent = node.collapsed ? '+' : '−';
                btn.onclick = e => {
                    e.stopPropagation();
                    toggleCollapse(node);
                };
                nodeEl.appendChild(btn);
                node.expandBtn = btn;
            }
              // Note indicator
            if (node.note && node.note.trim()) {
                const noteIndicator = document.createElement('div');
                noteIndicator.className = 'note-indicator has-note';
                noteIndicator.innerHTML = '📝';
                // Show note text in tooltip, truncate if too long
                const notePreview = node.note.length > 100 ? node.note.substring(0, 100) + '...' : node.note;
                noteIndicator.title = `Note: ${notePreview}\n\nClick to edit`;
                noteIndicator.onclick = e => {
                    e.stopPropagation();
                    openNoteModal(node);
                };
                nodeEl.appendChild(noteIndicator);
            } else {
                // Add empty note indicator for nodes without notes
                const noteIndicator = document.createElement('div');
                noteIndicator.className = 'note-indicator';
                noteIndicator.innerHTML = '+';
                noteIndicator.title = 'Add note';
                noteIndicator.onclick = e => {
                    e.stopPropagation();
                    openNoteModal(node);
                };
                nodeEl.appendChild(noteIndicator);
            }
            
            node.element = nodeEl;
            mindmapInner.appendChild(nodeEl);

            if (!node.collapsed) {
                node.children.forEach(child => renderSubtree(child));
            }
        }

        function drawEdge(parent, child) {
            if (!parent.element || !child.element) return;
            
            const parentRect = parent.element.getBoundingClientRect();
            const childRect = child.element.getBoundingClientRect();
            const containerRect = mindmapInner.getBoundingClientRect();
            
            // Calculate positions relative to the mindmap container
            const startX = (parentRect.right - containerRect.left) / zoom;
            const startY = (parentRect.top + parentRect.height / 2 - containerRect.top) / zoom;
            const endX = (childRect.left - containerRect.left) / zoom;
            const endY = (childRect.top + childRect.height / 2 - containerRect.top) / zoom;
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const midX = (startX + endX) / 2;
            path.setAttribute('d', `M${startX},${startY} C${midX},${startY} ${midX},${endY} ${endX},${endY}`);
            path.setAttribute('stroke', '#4299e1');
            path.setAttribute('stroke-width', '2');
            path.setAttribute('fill', 'none');
            path.setAttribute('opacity', '0.8');
            path.classList.add('edge');
            canvas.appendChild(path);
        }

        // --- Auto arrange (left->right tree, always visible) ---
        function autoArrange() {
            if (nodes.length === 0) return;
            // Find root(s)
            const roots = nodes.filter(n => !n.parent);
            
            // If we have existing roots, preserve their viewport position
            let preservedRootPosition = null;
            if (roots.length > 0 && roots[0].element) {
                const rootRect = roots[0].element.getBoundingClientRect();
                const containerRect = mindmapInner.getBoundingClientRect();
                preservedRootPosition = {
                    x: (rootRect.left - containerRect.left) / zoom,
                    y: (rootRect.top - containerRect.top) / zoom
                };
            }
              // Arrange multiple roots with proper spacing on the left side
            const leftMargin = 200; // Consistent left margin
            let currentY = 40;
            roots.forEach(root => {
                const subtreeHeight = measureSubtreeHeight(root);
                if (preservedRootPosition && root === roots[0]) {
                    // Keep first root at its current position
                    arrangeSubtree(root, root.x, root.y, 0);
                } else {
                    // Position other roots with proper spacing, aligned to left margin
                    arrangeSubtree(root, leftMargin, currentY + subtreeHeight / 2, 0);
                }
                currentY += subtreeHeight + 60; // Extra spacing between root trees
            });
            
            // Don't center the mindmap - let it grow from left to right
            // Only center vertically if this is initial load and no preserved position
            if (!preservedRootPosition && nodes.length > 0) {
                centerMindmapVertically();
            }
            
            scheduleRender();
        }

        function measureSubtreeHeight(node) {
            if (node.collapsed || node.children.length === 0) return 80;
            
            // Calculate the height needed for all children
            const childHeights = node.children.map(child => measureSubtreeHeight(child));
            const totalChildHeight = childHeights.reduce((sum, h) => sum + h, 0);
            const spacing = Math.max(20, 80 / node.children.length);
            const totalSpacing = Math.max(0, (node.children.length - 1) * spacing);
            
            // Return the maximum of node's own height or the total height of its children
            return Math.max(80, totalChildHeight + totalSpacing);
        }

        function arrangeSubtree(node, x, y, level) {
            // Only update position if this is root node being initially placed
            // or if it's a child node (always update children positions)
            if (level > 0 || !node.element) {
                node.x = x;
                node.y = y;
            }
            
            if (node.collapsed || node.children.length === 0) return;
            
            // Calculate total height needed for all children
            const childHeights = node.children.map(child => measureSubtreeHeight(child));
            const totalHeight = childHeights.reduce((sum, h) => sum + h, 0);
            const spacing = Math.max(20, 80 / node.children.length); // Dynamic spacing based on number of children
            
            // Start positioning children from the top of the allocated space
            let currentY = node.y - totalHeight / 2;
            
            node.children.forEach((child, index) => {
                const childHeight = childHeights[index];
                // Position child at the center of its allocated height
                const childCenterY = currentY + childHeight / 2;
                arrangeSubtree(child, node.x + 280, childCenterY, level + 1);
                // Move to next child's position
                currentY += childHeight + spacing;
            });
        }        function centerMindmap() {
            // Compute bounding box of all visible nodes
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            nodes.forEach(n => {
                if (isNodeVisible(n)) {
                    minX = Math.min(minX, n.x);
                    minY = Math.min(minY, n.y);
                    maxX = Math.max(maxX, n.x + 120);
                    maxY = Math.max(maxY, n.y + 40);
                }
            });
            if (minX === Infinity) return;
            const mapW = maxX - minX, mapH = maxY - minY;
            const cx = window.innerWidth / 2, cy = window.innerHeight / 2;
            pan.x = cx - (minX + mapW / 2) * zoom;
            pan.y = cy - (minY + mapH / 2) * zoom;
            applyTransform();
        }

        function centerMindmapVertically() {
            // Only center vertically, keep left alignment
            let minY = Infinity, maxY = -Infinity;
            nodes.forEach(n => {
                if (isNodeVisible(n)) {
                    minY = Math.min(minY, n.y);
                    maxY = Math.max(maxY, n.y + 40);
                }
            });
            if (minY === Infinity) return;
            const mapH = maxY - minY;
            const cy = window.innerHeight / 2;
            pan.y = cy - (minY + mapH / 2) * zoom;
            applyTransform();
        }

        function isNodeVisible(node) {
            if (!node.parent) return true;
            if (node.parent.collapsed) return false;
            return isNodeVisible(node.parent);
        }

        // --- Node selection and editing ---
        function selectNode(node) {
            // Only update selection classes, don't re-render
            if (selectedNode && selectedNode.element) {
                selectedNode.element.classList.remove('selected');
            }
            selectedNode = node;
            if (selectedNode && selectedNode.element) {
                selectedNode.element.classList.add('selected');
            }
        }

        function startEditing(node) {
            if (editingNode === node) return;
            editingNode = node;
            
            // Don't re-render, just update the node in place
            if (node.element) {
                node.element.classList.add('editing');
                const input = document.createElement('input');
                input.value = node.text;
                input.style.width = '100%';
                input.onkeydown = e => {
                    if (e.key === 'Enter') {
                        stopEditing(node, input.value);
                        e.preventDefault();
                    } else if (e.key === 'Escape') {
                        stopEditing(node, node.text);
                        e.preventDefault();
                    }
                    e.stopPropagation();
                };
                input.onblur = () => stopEditing(node, input.value);
                node.element.innerHTML = '';
                node.element.appendChild(input);
                input.focus();
                input.select();
            }
        }        function stopEditing(node, value) {
            node.text = value.trim() || 'New Idea';
            editingNode = null;
            
            // Don't re-render, just update the node in place
            if (node.element) {
                node.element.classList.remove('editing');
                
                // Clear all content first
                node.element.innerHTML = '';
                
                // Set the text content properly
                node.element.textContent = node.text;
                
                // Adjust width based on text length
                const textLength = node.text.length;
                if (textLength > 15) {
                    node.element.style.width = Math.min(200, Math.max(120, textLength * 8)) + 'px';
                }
                
                // Re-add expand button if needed
                if (node.children.length > 0) {
                    const btn = document.createElement('button');
                    btn.className = 'expand-btn';
                    btn.textContent = node.collapsed ? '+' : '−';
                    btn.onclick = e => {
                        e.stopPropagation();
                        toggleCollapse(node);
                    };
                    node.element.appendChild(btn);
                    node.expandBtn = btn;
                }
                  // Re-add note indicator
                if (node.note && node.note.trim()) {
                    const noteIndicator = document.createElement('div');
                    noteIndicator.className = 'note-indicator has-note';
                    noteIndicator.innerHTML = '📝';
                    // Show note text in tooltip, truncate if too long
                    const notePreview = node.note.length > 100 ? node.note.substring(0, 100) + '...' : node.note;
                    noteIndicator.title = `Note: ${notePreview}\n\nClick to edit`;
                    noteIndicator.onclick = e => {
                        e.stopPropagation();
                        openNoteModal(node);
                    };
                    node.element.appendChild(noteIndicator);
                } else {
                    // Add empty note indicator for nodes without notes
                    const noteIndicator = document.createElement('div');
                    noteIndicator.className = 'note-indicator';
                    noteIndicator.innerHTML = '+';
                    noteIndicator.title = 'Add note';
                    noteIndicator.onclick = e => {
                        e.stopPropagation();
                        openNoteModal(node);
                    };                    node.element.appendChild(noteIndicator);
                }
            }
        }

        // --- Expand/collapse ---
        function toggleCollapse(node) {
            node.collapsed = !node.collapsed;
            // Update button without re-rendering
            if (node.expandBtn) {
                node.expandBtn.textContent = node.collapsed ? '+' : '−';
            }
            
            // Hide/show children without full re-render
            if (node.collapsed) {
                // Hide all descendants
                hideDescendants(node);
            } else {
                // Show immediate children (they might have their own collapsed state)
                showChildren(node);
            }
              // Rearrange positions and redraw edges
            const roots = nodes.filter(n => !n.parent);
            const leftMargin = 200; // Use consistent left margin
            let y = 0;
            roots.forEach(root => {
                const subtreeHeight = measureSubtreeHeight(root);
                arrangeSubtree(root, leftMargin, y + 40, 0);
                y += subtreeHeight + 40;
            });
            
            // Update node positions
            nodes.forEach(n => {
                if (n.element) {
                    n.element.style.left = n.x + 'px';
                    n.element.style.top = n.y + 'px';
                }
            });
            
            // Redraw edges
            canvas.querySelectorAll('.edge').forEach(el => el.remove());
            setTimeout(() => {
                nodes.forEach(n => {
                    if (n.parent && !isNodeHidden(n)) {
                        drawEdge(n.parent, n);
                    }
                });
            }, 0);
        }
        
        function hideDescendants(node) {
            node.children.forEach(child => {
                if (child.element) {
                    child.element.style.display = 'none';
                }
                hideDescendants(child);
            });
        }
        
        function showChildren(node) {
            node.children.forEach(child => {
                if (child.element) {
                    child.element.style.display = 'flex';
                }
                if (!child.collapsed) {
                    showChildren(child);
                }
            });
        }

        // --- Delete functionality ---
        function deleteNode(node) {
            if (!node) return;
            
            // Check if node has children
            if (node.children.length > 0) {
                // Show confirmation dialog
                nodeToDelete = node;
                const childCount = countAllDescendants(node);
                document.getElementById('child-count').textContent = childCount;
                document.getElementById('overlay').classList.remove('hidden');
                document.getElementById('delete-confirm').classList.remove('hidden');
                
                // Focus on cancel button for better accessibility
                setTimeout(() => {
                    const cancelBtn = document.querySelector('.delete-confirm .cancel-btn');
                    if (cancelBtn) cancelBtn.focus();
                }, 10);
            } else {
                // No children, delete immediately
                performDelete(node);
            }
        }

        function countAllDescendants(node) {
            let count = node.children.length;
            node.children.forEach(child => {
                count += countAllDescendants(child);
            });
            return count;
        }

        function performDelete(node) {
            // Select another node before deletion
            let newSelection = null;
            if (node.parent) {
                const siblings = node.parent.children;
                const index = siblings.indexOf(node);
                if (index > 0) {
                    newSelection = siblings[index - 1];
                } else if (index < siblings.length - 1) {
                    newSelection = siblings[index + 1];
                } else {
                    newSelection = node.parent;
                }
            } else {
                // Deleting root, select another root if available
                const roots = nodes.filter(n => !n.parent);
                const rootIndex = roots.indexOf(node);
                if (roots.length > 1) {
                    newSelection = roots[rootIndex === 0 ? 1 : 0];
                }
            }

            // Remove from parent's children
            if (node.parent) {
                const index = node.parent.children.indexOf(node);
                if (index > -1) {
                    node.parent.children.splice(index, 1);
                }
                
                // Remove expand button if parent now has no children
                if (node.parent.children.length === 0 && node.parent.expandBtn) {
                    node.parent.expandBtn.remove();
                    node.parent.expandBtn = null;
                }
            }

            // Remove node and all descendants from nodes array
            const toRemove = [node];
            const collectDescendants = (n) => {
                n.children.forEach(child => {
                    toRemove.push(child);
                    collectDescendants(child);
                });
            };
            collectDescendants(node);
            
            toRemove.forEach(n => {
                const index = nodes.indexOf(n);
                if (index > -1) {
                    nodes.splice(index, 1);
                }
            });

            // Select new node
            if (newSelection) {
                selectNode(newSelection);
            } else {
                selectedNode = null;
            }

            // Re-arrange and render
            autoArrange();
        }

        function confirmDelete() {
            if (nodeToDelete) {
                performDelete(nodeToDelete);
                cancelDelete();
            }
        }

                function cancelDelete() {
            nodeToDelete = null;
            document.getElementById('overlay').classList.add('hidden');
            document.getElementById('delete-confirm').classList.add('hidden');
        }

        // --- Note functionality ---
        function openNoteModal(node) {
            currentNoteNode = node;
            const modal = document.getElementById('note-modal');
            const textarea = document.getElementById('note-textarea');
            const deleteBtn = document.getElementById('note-delete-btn');
            
            textarea.value = node.note || '';
            
            // Show/hide delete button based on whether note exists
            if (node.note && node.note.trim()) {
                deleteBtn.style.display = 'inline-block';
            } else {
                deleteBtn.style.display = 'none';
            }
            
            modal.classList.remove('hidden');
            document.getElementById('overlay').classList.remove('hidden');
            
            // Add keyboard handler for the textarea
            textarea.onkeydown = (e) => {
                if (e.key === 'Escape') {
                    closeNoteModal();
                    e.preventDefault();
                } else if (e.ctrlKey && e.key === 'Enter') {
                    saveNote();
                    e.preventDefault();
                }
                e.stopPropagation();
            };
            
            setTimeout(() => {
                textarea.focus();
                textarea.select();            }, 100);
        }        function closeNoteModal() {
            const modal = document.getElementById('note-modal');
            const textarea = document.getElementById('note-textarea');
            modal.classList.add('hidden');
            document.getElementById('overlay').classList.add('hidden');
            
            // Remove the keyboard handler
            textarea.onkeydown = null;
            currentNoteNode = null;
        }

        function saveNote() {
            if (currentNoteNode) {
                const textarea = document.getElementById('note-textarea');
                currentNoteNode.note = textarea.value.trim();
                render();  // Re-render to update note indicators
                closeNoteModal();
            }
        }

        function deleteNote() {
            if (currentNoteNode) {
                currentNoteNode.note = '';
                render();  // Re-render to update note indicators
                closeNoteModal();
            }
        }        // Make functions globally accessible for onclick handlers
        window.closeNoteModal = closeNoteModal;
        window.saveNote = saveNote;
        window.deleteNote = deleteNote;
        window.saveMindMapAsMarkdown = saveMindMapAsMarkdown;
        window.loadMindMapFromMarkdown = loadMindMapFromMarkdown;
        window.toggleInstructions = toggleInstructions;
        window.cancelDelete = cancelDelete;
        window.confirmDelete = confirmDelete;// --- Keyboard controls ---
        document.addEventListener('keydown', e => {
            // Handle escape key for note modal
            if (!document.getElementById('note-modal').classList.contains('hidden')) {
                if (e.key === 'Escape') {
                    closeNoteModal();
                    e.preventDefault();
                }
                return; // Don't process other keys when note modal is open
            }
            
            // Handle escape key for delete confirmation
            if (!document.getElementById('delete-confirm').classList.contains('hidden')) {
                if (e.key === 'Escape') {
                    cancelDelete();
                    e.preventDefault();
                }
                return; // Don't process other keys when dialog is open
            }
            
            if (nodes.length === 0 && e.key === 'Enter') {
                createFirstNode({ clientX: window.innerWidth / 2, clientY: window.innerHeight / 2 });
                return;
            }
            if (!selectedNode) return;

            // Editing - only handle if selected
            if (e.key === 'Enter' && !e.ctrlKey) {
                if (editingNode === selectedNode) {
                    // If already editing, Enter will be handled by input's keydown
                    return;
                } else {
                    startEditing(selectedNode);
                    e.preventDefault();
                    return;
                }
            }

            // Don't handle other keys while editing
            if (editingNode) return;            // Delete key
            if (e.key === 'Delete') {
                if (selectedNode) {
                    deleteNode(selectedNode);
                    e.preventDefault();
                }
                return;
            }

            // Note key (N)
            if (e.key === 'n' || e.key === 'N') {
                if (selectedNode) {
                    openNoteModal(selectedNode);
                    e.preventDefault();
                }
                return;
            }

            // Navigation
            if (!e.ctrlKey) {
                if (e.key === 'ArrowRight') {
                    // Go to nearest child
                    if (!selectedNode.collapsed && selectedNode.children.length > 0) {
                        // Find child closest to current Y position
                        let closestChild = selectedNode.children[0];
                        let minDistance = Math.abs(closestChild.y - selectedNode.y);
                        
                        selectedNode.children.forEach(child => {
                            const distance = Math.abs(child.y - selectedNode.y);
                            if (distance < minDistance) {
                                minDistance = distance;
                                closestChild = child;
                            }
                        });
                        selectNode(closestChild);
                    }
                } else if (e.key === 'ArrowLeft') {
                    // Always go to parent
                    if (selectedNode.parent) selectNode(selectedNode.parent);
                } else if (e.key === 'ArrowUp') {
                    // Strictly vertical up - find node directly above
                    const targetNode = findNodeVertically(selectedNode, 'up');
                    if (targetNode) selectNode(targetNode);
                } else if (e.key === 'ArrowDown') {
                    // Strictly vertical down - find node directly below
                    const targetNode = findNodeVertically(selectedNode, 'down');
                    if (targetNode) selectNode(targetNode);
                }
            }

            // Structure changes
            if (e.ctrlKey) {
                if (e.key === 'ArrowRight') {
                    if (selectedNode.collapsed) {
                        selectedNode.collapsed = false;
                        // Just update the button without full re-render
                        if (selectedNode.expandBtn) {
                            selectedNode.expandBtn.textContent = '−';
                        }
                        autoArrange();
                        // Focus on first child after expanding
                        if (selectedNode.children.length > 0) {
                            setTimeout(() => {
                                selectNode(selectedNode.children[0]);
                            }, 50);
                        }
                    } else {
                        createChildNode(selectedNode);
                    }
                    e.preventDefault();
                } else if (e.key === 'ArrowLeft') {
                    // Collapse current node if it has children, otherwise collapse parent
                    if (selectedNode.children.length > 0) {
                        // Current node has children
                        if (!selectedNode.collapsed) {
                            // Not collapsed - collapse it
                            selectedNode.collapsed = true;
                            autoArrange();
                        } else if (selectedNode.parent && selectedNode.parent.children.length > 0) {
                            // Already collapsed - collapse parent if it has children
                            if (!selectedNode.parent.collapsed) {
                                selectedNode.parent.collapsed = true;
                                selectNode(selectedNode.parent);
                                autoArrange();
                            }
                        }
                    } else if (selectedNode.parent && selectedNode.parent.children.length > 0) {
                        // No children, but parent has children - collapse parent and select it
                        if (!selectedNode.parent.collapsed) {
                            selectedNode.parent.collapsed = true;
                            selectNode(selectedNode.parent);
                            autoArrange();
                        }
                    }
                    e.preventDefault();
                } else if (e.key === 'ArrowDown') {
                    if (selectedNode.parent) {
                        createSiblingNode(selectedNode, 1);
                    }
                    e.preventDefault();
                } else if (e.key === 'ArrowUp') {
                    if (selectedNode.parent) {
                        createSiblingNode(selectedNode, 0);
                    }
                    e.preventDefault();
                }
            }
        });

        function getVisibleSiblings(node) {
            if (!node.parent) return [node];
            return node.parent.children;
        }

        function findNodeInDirection(fromNode, direction) {
            // Get all visible nodes
            const visibleNodes = [];
            nodes.forEach(node => {
                if (isNodeVisible(node)) {
                    visibleNodes.push(node);
                }
            });

            // Sort by Y position
            visibleNodes.sort((a, b) => a.y - b.y);

            // Find nodes in the target direction
            const currentY = fromNode.y;
            const currentX = fromNode.x;
            let candidates = [];

            if (direction === 'up') {
                candidates = visibleNodes.filter(n => n.y < currentY - 10);
                candidates.sort((a, b) => b.y - a.y); // Closest first
            } else {
                candidates = visibleNodes.filter(n => n.y > currentY + 10);
                candidates.sort((a, b) => a.y - b.y); // Closest first
            }

            // Find the best candidate (closest in X direction among the closest in Y)
            if (candidates.length > 0) {
                // Group by similar Y position (within 30px)
                const firstY = candidates[0].y;
                const similarY = candidates.filter(n => Math.abs(n.y - firstY) < 30);
                
                // Among those, find closest X
                similarY.sort((a, b) => Math.abs(a.x - currentX) - Math.abs(b.x - currentX));
                return similarY[0];
            }

            return null;
        }

        function findNodeVertically(fromNode, direction) {
            // Get all visible nodes at the same generation level (siblings and cousins)
            const visibleNodes = [];
            const fromLevel = getNodeLevel(fromNode);
            
            nodes.forEach(node => {
                if (isNodeVisible(node) && node !== fromNode && getNodeLevel(node) === fromLevel) {
                    visibleNodes.push(node);
                }
            });

            const currentY = fromNode.y;
            
            // Filter nodes in the target direction
            let candidates = [];
            if (direction === 'up') {
                candidates = visibleNodes.filter(n => n.y < currentY);
                candidates.sort((a, b) => b.y - a.y); // Sort by Y descending (closest first)
            } else {
                candidates = visibleNodes.filter(n => n.y > currentY);
                candidates.sort((a, b) => a.y - b.y); // Sort by Y ascending (closest first)
            }

            // Return the closest node vertically
            if (candidates.length > 0) {
                return candidates[0];
            }

            return null;
        }

        function getNodeLevel(node) {
            let level = 0;
            let current = node;
            while (current.parent) {
                level++;
                current = current.parent;
            }
            return level;
        }

        function createChildNode(parent) {
            if (parent.collapsed) {
                parent.collapsed = false;
                // Update button without re-rendering
                if (parent.expandBtn) {
                    parent.expandBtn.textContent = '−';
                }
            }
            const node = createNode('New Node', 0, 0, parent);
            
            // If parent didn't have children before, it needs an expand button now
            if (parent.children.length === 1 && parent.element && !parent.expandBtn) {
                const btn = document.createElement('button');
                btn.className = 'expand-btn';
                btn.textContent = '−';
                btn.onclick = e => {
                    e.stopPropagation();
                    toggleCollapse(parent);
                };
                parent.element.appendChild(btn);
                parent.expandBtn = btn;
            }
            
            autoArrange();
            // Select and start editing after render
            setTimeout(() => {
                selectNode(node);
                startEditing(node);
            }, 50);
        }

        function createSiblingNode(node, below = 1) {
            if (!node.parent) return;
            const parent = node.parent;
            const idx = parent.children.indexOf(node);
            const newNode = createNode('New Node', 0, 0, parent);
            parent.children.splice(parent.children.indexOf(newNode), 1); // Remove from end
            parent.children.splice(idx + below, 0, newNode);
            
            // Full re-arrange to fix positioning
            autoArrange();
            
            // Select and start editing after render
            setTimeout(() => {
                selectNode(newNode);
                startEditing(newNode);
            }, 50);
        }

        // --- Save/Load ---
        // Remove saveMindMap and loadMindMap functions
        
        // --- Markdown Save/Load ---
        function saveMindMapAsMarkdown() {
            // Find root nodes
            const roots = nodes.filter(n => !n.parent);
            let markdown = '# Mind Map\n\n';
            
            // Save metadata about collapsed states
            const collapsedNodes = nodes.filter(n => n.collapsed).map(n => n.text);
            if (collapsedNodes.length > 0) {
                markdown += '<!-- MINDMAP_META\n';
                markdown += JSON.stringify({ collapsed: collapsedNodes });
                markdown += '\n-->\n\n';
            }
            
            // Convert tree to markdown
            roots.forEach(root => {
                markdown += nodeToMarkdown(root, 0);
            });
            
            const blob = new Blob([markdown], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'mindmap.md';
            a.click();
            URL.revokeObjectURL(url);
        }
          function nodeToMarkdown(node, level) {
            let markdown = '';
            const indent = '  '.repeat(level);
            markdown += indent + '- ' + node.text + '\n';
            
            // Add note if it exists
            if (node.note && node.note.trim()) {
                const noteLines = node.note.trim().split('\n');
                noteLines.forEach(line => {
                    markdown += indent + '  > ' + line + '\n';
                });
            }
            
            if (!node.collapsed) {
                node.children.forEach(child => {
                    markdown += nodeToMarkdown(child, level + 1);
                });
            }
            
            return markdown;
        }
        
        function loadMindMapFromMarkdown() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.md,.markdown';
            input.onchange = e => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = e => {
                        try {
                            parseMarkdownToMindMap(e.target.result);
                        } catch (err) {
                            alert('Error loading markdown: ' + err.message);
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }
        
        function parseMarkdownToMindMap(markdown) {
            nodes = [];
            selectedNode = null;
            nextId = 1;
            
            // Extract metadata
            let collapsedTexts = [];
            const metaMatch = markdown.match(/<!-- MINDMAP_META\n(.*?)\n-->/s);
            if (metaMatch) {
                try {
                    const meta = JSON.parse(metaMatch[1]);
                    collapsedTexts = meta.collapsed || [];
                } catch (e) {
                    console.warn('Failed to parse metadata:', e);
                }
            }
              // Parse markdown lines
            const lines = markdown.split('\n');
            const nodeStack = [];
            let currentNode = null;
            
            lines.forEach(line => {
                // Skip empty lines and metadata
                if (!line.trim() || line.startsWith('<!--') || line.startsWith('#')) return;
                
                // Check if this is a note line (indented >)
                const noteMatch = line.match(/^(\s*)>\s*(.*)$/);
                if (noteMatch && currentNode) {
                    const noteText = noteMatch[2];
                    if (currentNode.note) {
                        currentNode.note += '\n' + noteText;
                    } else {
                        currentNode.note = noteText;
                    }
                    return;
                }
                
                // Count indentation (2 spaces per level)
                const indentMatch = line.match(/^(\s*)-\s*(.+)$/);
                if (indentMatch) {
                    const indent = indentMatch[1].length / 2;
                    const text = indentMatch[2].trim();
                    
                    // Find parent based on indentation
                    let parent = null;
                    if (indent > 0 && nodeStack.length > 0) {
                        // Find the closest parent at the correct level
                        for (let i = nodeStack.length - 1; i >= 0; i--) {
                            if (nodeStack[i].level < indent) {
                                parent = nodeStack[i].node;
                                break;
                            }
                        }
                    }
                    
                    // Create node
                    const node = createNode(text, 0, 0, parent);
                    currentNode = node; // Set as current for note processing
                    
                    // Set collapsed state if this node was collapsed
                    if (collapsedTexts.includes(text)) {
                        node.collapsed = true;
                    }
                    
                    // Update stack
                    nodeStack.push({ node, level: indent });
                    
                    // Clean up stack - remove nodes at same or deeper level
                    while (nodeStack.length > 1 && 
                           nodeStack[nodeStack.length - 2].level >= indent) {
                        nodeStack.splice(nodeStack.length - 2, 1);
                    }
                }
            });
            
            autoArrange();
            if (nodes.length > 0) selectNode(nodes[0]);
        }

        // --- UI Functions ---
        function toggleInstructions() {
            const instructions = document.getElementById('instructions');
            instructions.classList.toggle('collapsed');
            instructions.classList.toggle('expanded');
        }        // --- Initial ---
        canvasContainer.style.cursor = 'grab';
        window.addEventListener('resize', () => {
            autoArrange();
        });

        // Ensure modals are hidden on load
        document.getElementById('note-modal').classList.add('hidden');
        document.getElementById('overlay').classList.add('hidden');
        document.getElementById('delete-confirm').classList.add('hidden');

        // Initial render
        scheduleRender();
    </script>
</body>
</html>