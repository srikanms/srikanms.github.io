<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mind Map Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #ffffff;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }        .toolbar {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .file-status {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 13px;
            color: #4a5568;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 6px;
            max-width: 300px;
            min-width: 120px;
        }

        .file-status .file-icon {
            font-size: 14px;
        }

        .file-status .file-name {
            font-weight: 500;
            color: #2d3748;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex: 1;
        }

        .file-status .unsaved-indicator {
            color: #e53e3e;
            font-weight: bold;
            font-size: 16px;
            margin-left: 2px;
        }

        .file-status.no-file {
            opacity: 0.7;
            font-style: italic;
        }

        .toolbar button {
            padding: 10px 16px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background: #ffffff;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            color: #4a5568;
        }

        .toolbar button:hover {
            background: #f7fafc;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border-color: #cbd5e0;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            cursor: grab;
            background: #ffffff;
        }

        #canvas-container:active {
            cursor: grabbing;
        }

        #mindmap-inner {
            position: absolute;
            top: 0;
            left: 0;
            will-change: transform;
            width: 100%;
            height: 100%;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: visible;
        }        .node {
            position: absolute;
            min-width: 120px;
            max-width: 200px;
            min-height: 40px;
            background: #ffffff;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            cursor: pointer;
            transition: border-color 0.3s ease, background-color 0.3s ease, box-shadow 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            font-size: 14px;
            font-weight: 500;
            color: #2d3748;
            padding: 8px 16px;
            text-align: left;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            z-index: 10;
            white-space: pre-wrap;
            line-height: 1.3;
        }

        .node:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border-color: #cbd5e0;
        }

        .node.selected {
            border-color: #4299e1;
            background: #ebf8ff;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.3);
        }

        .node.editing {
            background: #ffffff;
            border-color: #4299e1;
        }        .node input {
            border: none;
            outline: none;
            background: transparent;
            font-size: 14px;
            font-weight: 500;
            color: #2d3748;
            text-align: left;
            width: 100%;
            min-width: 100px;
            flex: 1;
        }

        .expand-btn {
            position: absolute;
            right: -12px;
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 24px;
            border: 1px solid #e2e8f0;
            border-radius: 50%;
            background: #4299e1;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
            z-index: 20;
        }

        .expand-btn:hover {
            background: #3182ce;
            transform: translateY(-50%) scale(1.1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .edge {
            position: absolute;
            pointer-events: none;
            z-index: 1;
        }

        .instructions {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(45, 55, 72, 0.95);
            color: white;
            border-radius: 8px;
            font-size: 12px;
            max-width: 320px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .instructions.collapsed {
            cursor: pointer;
            padding: 10px 15px;
        }

        .instructions.expanded {
            padding: 15px;
        }

        .instructions-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .instructions.collapsed .instructions-header {
            margin-bottom: 0;
        }

        .instructions-content {
            display: block;
        }

        .instructions.collapsed .instructions-content {
            display: none;
        }

        .instructions-toggle {
            font-size: 14px;
            opacity: 0.8;
            transition: transform 0.3s ease;
        }

        .instructions.collapsed .instructions-toggle {
            transform: rotate(-90deg);
        }

        .instructions-hint {
            font-size: 11px;
            opacity: 0.7;
            margin-left: 8px;
        }

        .instructions.expanded .instructions-hint {
            display: none;
        }

        .instructions div {
            margin-bottom: 5px;
        }

        .delete-confirm {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            min-width: 300px;
            text-align: center;
        }

        .delete-confirm h3 {
            margin: 0 0 10px 0;
            color: #2d3748;
        }

        .delete-confirm p {
            margin: 0 0 20px 0;
            color: #718096;
            font-size: 14px;
        }

        .delete-confirm-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .delete-confirm button {
            padding: 8px 20px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .delete-confirm .confirm-btn {
            background: #e53e3e;
            color: white;
            border-color: #e53e3e;
        }

        .delete-confirm .confirm-btn:hover {
            background: #c53030;
            border-color: #c53030;
        }

        .delete-confirm .cancel-btn {
            background: white;
            color: #4a5568;
        }

        .delete-confirm .cancel-btn:hover {
            background: #f7fafc;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            z-index: 1999;
        }

        .hidden {
            display: none !important;
        }        /* Checkbox styles */
        .node-checkbox {
            width: 16px;
            height: 16px;
            border: 2px solid #cbd5e0;
            border-radius: 3px;
            background: #ffffff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
            margin-right: 8px;
        }

        .node-checkbox:hover {
            border-color: #4299e1;
            background: #f7fafc;
        }

        .node-checkbox.checked {
            background: #4299e1;
            border-color: #4299e1;
            color: white;
        }

        .node-checkbox.checked::after {
            content: '‚úì';
            font-size: 12px;
            font-weight: bold;
        }

        .node.completed {
            opacity: 0.7;
        }        .node.completed .node-content {
            text-decoration: line-through;
            color: #718096;
        }

        .node-content {
            flex: 1;
            text-align: left;
        }

        /* Note feature styles - only show when note exists */
        .note-indicator {
            position: absolute;
            top: -12px;
            left: -12px;
            width: 22px;
            height: 22px;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid #e2e8f0;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            color: #718096;
            z-index: 25;
            transition: all 0.3s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        }

        .note-indicator:hover {
            transform: scale(1.1);
            background: rgba(255, 255, 255, 1);
            border-color: #cbd5e0;
            color: #4a5568;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12);
        }

        /* Context menu styles */
        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15);
            z-index: 3000;
            min-width: 150px;
            padding: 8px 0;
            font-size: 14px;
        }

        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .context-menu-item:hover {
            background: #f7fafc;
        }

        .context-menu-item.disabled {
            color: #a0aec0;
            cursor: not-allowed;
        }

        .context-menu-item.disabled:hover {
            background: transparent;
        }

        .note-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
            z-index: 2001;
            min-width: 400px;
            max-width: 600px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }

        .note-modal-header {
            padding: 20px 20px 10px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .note-modal-header h3 {
            margin: 0;
            color: #2d3748;
            font-size: 18px;
        }

        .note-modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #718096;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .note-modal-close:hover {
            background: #f7fafc;
            color: #2d3748;
        }

        .note-modal-body {
            padding: 20px;
            flex: 1;
            overflow-y: auto;
        }

        .note-textarea {
            width: 100%;
            min-height: 200px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 12px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px;
            line-height: 1.5;
            resize: vertical;
            outline: none;
            transition: border-color 0.3s ease;
        }

        .note-textarea:focus {
            border-color: #4299e1;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.1);
        }

        .note-modal-footer {
            padding: 15px 20px;
            border-top: 1px solid #e2e8f0;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .note-modal-footer button {
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
            border: 1px solid #e2e8f0;
        }

        .note-save-btn {
            background: #4299e1;
            color: white;
            border-color: #4299e1;
        }

        .note-save-btn:hover {
            background: #3182ce;
            border-color: #3182ce;
        }

        .note-cancel-btn {
            background: white;
            color: #4a5568;
        }

        .note-cancel-btn:hover {
            background: #f7fafc;
        }

        .note-delete-btn {
            background: #e53e3e;
            color: white;
            border-color: #e53e3e;
        }

        .note-delete-btn:hover {
            background: #c53030;
            border-color: #c53030;
        }

        /* Hover controls for node creation */
        .hover-control {
            position: absolute;
            width: 24px;
            height: 24px;
            background: rgba(66, 153, 225, 0.1);
            border: 1px solid rgba(66, 153, 225, 0.3);
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            color: #4299e1;
            z-index: 30;
            transition: all 0.2s ease;
        }

        .hover-control:hover {
            background: rgba(66, 153, 225, 0.2);
            border-color: rgba(66, 153, 225, 0.6);
            transform: scale(1.1);
        }

        .hover-control.right {
            right: -36px;
            top: 50%;
            transform: translateY(-50%);
        }

        .hover-control.right:hover {
            transform: translateY(-50%) scale(1.1);
        }

        .hover-control.down {
            bottom: -36px;
            left: 50%;
            transform: translateX(-50%);
        }

        .hover-control.down:hover {
            transform: translateX(-50%) scale(1.1);
        }

        .hover-control.up {
            top: -36px;
            left: 50%;
            transform: translateX(-50%);
        }

        .hover-control.up:hover {
            transform: translateX(-50%) scale(1.1);
        }

        /* Create bridge areas between node and controls to prevent hover loss */
        .hover-control.right::before {
            content: '';
            position: absolute;
            width: 12px;
            height: 24px;
            left: -12px;
            top: 0;
            background: transparent;
        }

        .hover-control.up::before {
            content: '';
            position: absolute;
            width: 24px;
            height: 12px;
            left: 0;
            bottom: -12px;
            background: transparent;
        }

        .hover-control.down::before {
            content: '';
            position: absolute;
            width: 24px;
            height: 12px;
            left: 0;
            top: -12px;
            background: transparent;
        }

        /* Show controls on node hover or when hovering controls themselves */
        .node:hover .hover-control,
        .hover-control:hover {
            display: flex !important;
        }

        #save-notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(40, 40, 40, 0.85);
            color: #f0f0f0;
            padding: 12px 24px;
            border-radius: 8px;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease-out, visibility 0s linear 0.5s;
            font-family: sans-serif;
            font-size: 14px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        #save-notification.show {
            opacity: 1;
            visibility: visible;
            transition: opacity 0.5s ease-out, visibility 0s linear 0s;
        }
    </style>
</head>

<body>    <div class="toolbar">
        <div class="file-status no-file" id="file-status">
            <span class="file-icon">üìÑ</span>
            <span class="file-name" id="file-name">Untitled</span>
            <span class="unsaved-indicator" id="unsaved-indicator" style="display: none;">*</span>
        </div>
        <button onclick="saveMindMapAsMarkdown()">üìù Save Markdown</button>
        <button onclick="saveMindMapAsNewFile()">üíæ Save As...</button> <!-- Added Save As button -->
        <button onclick="loadMindMapFromMarkdown()">üìÑ Load Markdown</button>
    </div>

    <div id="canvas-container">
        <div id="mindmap-inner">
            <svg id="canvas" width="100%" height="100%">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#4299e1" opacity="0.8" />
                    </marker>
                </defs>
            </svg>
        </div>
    </div>

    <div class="instructions collapsed" id="instructions">
        <div class="instructions-header" onclick="toggleInstructions()">
            <div>
                <strong>Controls</strong>
                <span class="instructions-hint">(click to expand)</span>
            </div>
            <span class="instructions-toggle">‚ñº</span>
        </div>        <div class="instructions-content">
            <div>Click/Enter: Create first node</div>
            <div>Enter: Edit selected node</div>
            <div>Space: Toggle checkbox completion</div>
            <div>N: Add/edit note for selected node</div>
            <div>Delete: Delete node</div>
            <div>Ctrl+‚Üí: Add child or Expand</div>
            <div>Ctrl+‚Üì: Add sibling below</div>
            <div>Ctrl+‚Üë: Add sibling above</div>
            <div>Ctrl+‚Üê: Progressive collapse</div>
            <div>Arrow keys: Navigate</div>
            <div>Mouse wheel: Zoom</div>
            <div>Click & drag canvas: Pan</div>
        </div>
    </div>

    <div id="overlay" class="overlay hidden"></div>
    <div id="delete-confirm" class="delete-confirm hidden">
        <h3>Delete Node?</h3>
        <p>Are you sure you want to delete this node?</p>
        <div class="delete-confirm-buttons">
            <button class="cancel-btn" onclick="cancelDelete()">Cancel</button>
            <button class="confirm-btn" onclick="confirmDelete()">Delete</button>
        </div>
    </div>

    <!-- Note modal -->
    <div id="note-modal" class="note-modal hidden">
        <div class="note-modal-header">
            <h3>Node Note</h3>
            <button class="note-modal-close" onclick="closeNoteModal()">√ó</button>
        </div>
        <div class="note-modal-body">
            <textarea id="note-textarea" class="note-textarea" placeholder="Add your note here..."></textarea>
        </div>
        <div class="note-modal-footer">
            <button class="note-delete-btn" onclick="deleteNote()" id="note-delete-btn" style="display: none;">Delete
                Note</button>
            <button class="note-cancel-btn" onclick="closeNoteModal()">Cancel</button>
            <button class="note-save-btn" onclick="saveNote()">Save Note</button>
        </div>
    </div>

    <script>        // --- State ---
        let nodes = [];
        let selectedNode = null;
        let nextId = 1;
        let pan = { x: 0, y: 0 };
        let zoom = 1;
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        let dragStart = { x: 0, y: 0 };
        let editingNode = null;
        let renderScheduled = false;
        let nodeToDelete = null;
        let currentNoteNode = null; // For note editing

        const canvasContainer = document.getElementById('canvas-container');
        const mindmapInner = document.getElementById('mindmap-inner');
        const canvas = document.getElementById('canvas');

        // --- Pan/Zoom ---
        function applyTransform() {
            mindmapInner.style.transform = `translate(${pan.x}px,${pan.y}px) scale(${zoom})`;
        }
        applyTransform();

        canvasContainer.addEventListener('mousedown', e => {
            if (e.button !== 0) return;
            // Check if clicking on empty space
            if (e.target === canvasContainer || e.target === mindmapInner || e.target === canvas) {
                if (nodes.length === 0) {
                    createFirstNode(e);
                    return;
                }
                isPanning = true;
                panStart = { x: e.clientX, y: e.clientY };
                dragStart = { x: pan.x, y: pan.y };
                canvasContainer.style.cursor = 'grabbing';
            }
        });

        window.addEventListener('mousemove', e => {
            if (isPanning) {
                pan.x = dragStart.x + (e.clientX - panStart.x);
                pan.y = dragStart.y + (e.clientY - panStart.y);
                applyTransform();
            }
        });

        window.addEventListener('mouseup', e => {
            isPanning = false;
            canvasContainer.style.cursor = 'grab';
        });

        canvasContainer.addEventListener('wheel', e => {
            e.preventDefault();
            const scale = Math.exp(-e.deltaY * 0.001);
            const rect = mindmapInner.getBoundingClientRect();
            const cx = (e.clientX - rect.left) / zoom;
            const cy = (e.clientY - rect.top) / zoom;
            zoom *= scale;
            zoom = Math.max(0.2, Math.min(zoom, 2.5));
            pan.x -= (cx * (scale - 1)) * zoom;
            pan.y -= (cy * (scale - 1)) * zoom;
            applyTransform();
        }, { passive: false });        // --- Node creation ---
        function createFirstNode(e) {
            // Position the first node on the left side with nice margin (200px from left edge)
            const leftMargin = 200;
            const x = (leftMargin - pan.x) / zoom;
            const y = (window.innerHeight / 2 - pan.y) / zoom;
            const node = createNode('New Idea', x, y, null);
            scheduleRender();
            // Wait for render to complete before selecting and editing
            setTimeout(() => {
                selectNode(node);
                startEditing(node);
            }, 50);
        }
        
        function createNode(text, x, y, parent) {
            const node = {
                id: nextId++,
                text,
                x, y,
                parent,
                children: [],
                collapsed: false,
                element: null,
                expandBtn: null,
                note: '', // Add note property
                completed: false // Add completed property for checkbox functionality
            };
            if (parent) parent.children.push(node);
            nodes.push(node);
            
            // Mark as changed when creating new nodes (except during initial load)
            if (nodes.length > 1 || text !== 'New Idea') {
                markAsChanged();
            }
            
            return node;
        }

        // --- Performance optimized rendering ---
        function scheduleRender() {
            if (!renderScheduled) {
                renderScheduled = true;
                requestAnimationFrame(() => {
                    render();
                    renderScheduled = false;
                });
            }
        }

        // Lightweight update for position changes only (no flickering)
        function updatePositionsAndEdges() {
            // Update node positions without recreating elements
            nodes.forEach(node => {
                if (node.element) {
                    node.element.style.left = node.x + 'px';
                    node.element.style.top = node.y + 'px';

                    // Update visibility based on collapsed state
                    if (isNodeHidden(node)) {
                        node.element.style.display = 'none';
                    } else {
                        node.element.style.display = 'flex';
                    }
                }
            });

            // Smoothly update edges without clearing everything
            updateEdges();
        }

        function updateEdges() {
            // Remove existing edges but keep defs
            const edges = canvas.querySelectorAll('.edge');
            edges.forEach(edge => edge.remove());

            // Redraw edges
            nodes.forEach(node => {
                if (node.parent && !isNodeHidden(node)) {
                    drawEdge(node.parent, node);
                }
            });
        }

        function render() {
            // Remove all node elements
            mindmapInner.querySelectorAll('.node').forEach(el => el.remove());
            // Clear canvas edges
            while (canvas.firstChild) {
                canvas.removeChild(canvas.firstChild);
            }
            // Re-add defs
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            marker.setAttribute('id', 'arrowhead');
            marker.setAttribute('markerWidth', '10');
            marker.setAttribute('markerHeight', '7');
            marker.setAttribute('refX', '9');
            marker.setAttribute('refY', '3.5');
            marker.setAttribute('orient', 'auto');
            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
            polygon.setAttribute('fill', '#4299e1');
            polygon.setAttribute('opacity', '0.8');
            marker.appendChild(polygon);
            defs.appendChild(marker);
            canvas.appendChild(defs);

            // Render nodes recursively
            nodes.forEach(node => {
                if (!node.parent) renderSubtree(node);
            });

            // Render edges after all nodes are rendered
            setTimeout(() => {
                nodes.forEach(node => {
                    if (node.parent && !isNodeHidden(node)) {
                        drawEdge(node.parent, node);
                    }
                });
            }, 0);
        }

        function isNodeHidden(node) {
            if (!node.parent) return false;
            if (node.parent.collapsed) return true;
            return isNodeHidden(node.parent);
        }
        
        function renderSubtree(node) {
            // Node element
            const nodeEl = document.createElement('div');
            nodeEl.className = 'node';
            if (node.completed) nodeEl.classList.add('completed');
            nodeEl.style.left = node.x + 'px';
            nodeEl.style.top = node.y + 'px';

            // Add checkbox
            const checkbox = document.createElement('div');
            checkbox.className = 'node-checkbox';
            if (node.completed) checkbox.classList.add('checked');
            checkbox.onclick = e => {
                e.stopPropagation();
                toggleNodeCompletion(node);
            };
            nodeEl.appendChild(checkbox);

            // Create content wrapper for text (to apply strikethrough when completed)
            const contentWrapper = document.createElement('span');
            contentWrapper.className = 'node-content';
            
            // Better text handling
            const textContent = node.text || 'New Node';
            contentWrapper.textContent = textContent;
            nodeEl.appendChild(contentWrapper);

            // Adjust width based on text length (account for checkbox width)
            const textLength = textContent.length;
            if (textLength > 12) {
                nodeEl.style.width = Math.min(200, Math.max(140, textLength * 8 + 32)) + 'px';
            } else {
                nodeEl.style.width = '140px';
            }

            if (selectedNode === node) nodeEl.classList.add('selected');
            if (editingNode === node) nodeEl.classList.add('editing');nodeEl.onclick = e => {
                e.stopPropagation();
                selectNode(node);
            };

            // Add right-click context menu
            nodeEl.oncontextmenu = e => {
                e.preventDefault();
                e.stopPropagation();
                showContextMenu(e, node);
            };
            // Expand/collapse button
            if (node.children.length > 0) {
                const btn = document.createElement('button');
                btn.className = 'expand-btn';
                btn.textContent = node.collapsed ? '+' : '‚àí';
                btn.onclick = e => {
                    e.stopPropagation();
                    toggleCollapse(node);
                };
                nodeEl.appendChild(btn);
                node.expandBtn = btn;
            }            // Note indicator - only show when note exists
            if (node.note && node.note.trim()) {
                const noteIndicator = document.createElement('div');
                noteIndicator.className = 'note-indicator has-note';
                noteIndicator.innerHTML = 'üìù';
                // Show note text in tooltip, truncate if too long
                const notePreview = node.note.length > 100 ? node.note.substring(0, 100) + '...' : node.note;
                noteIndicator.title = `Note: ${notePreview}\n\nClick to edit`;
                noteIndicator.onclick = e => {
                    e.stopPropagation();
                    openNoteModal(node);
                };
                nodeEl.appendChild(noteIndicator);
            }

            // Add hover controls for node creation
            addHoverControls(nodeEl, node);

            node.element = nodeEl;
            mindmapInner.appendChild(nodeEl); if (!node.collapsed) {
                node.children.forEach(child => renderSubtree(child));
            }
        } 
        
        function addHoverControls(nodeEl, node) {
            const isRoot = !node.parent;
            const hasChildren = node.children.length > 0;

            // Remove all previous hover controls if any
            nodeEl.querySelectorAll('.hover-control').forEach(ctrl => ctrl.remove());

            if (hasChildren) {
                // Any node with children: only show up/down controls for non-root nodes
                if (!isRoot) {
                    const upControl = document.createElement('div');
                    upControl.className = 'hover-control up';
                    upControl.innerHTML = '+';
                    upControl.title = 'Add sibling above';
                    upControl.onclick = e => {
                        e.stopPropagation();
                        createSiblingNode(node, 0);
                    };
                    nodeEl.appendChild(upControl);

                    const downControl = document.createElement('div');
                    downControl.className = 'hover-control down';
                    downControl.innerHTML = '+';
                    downControl.title = 'Add sibling below';
                    downControl.onclick = e => {
                        e.stopPropagation();
                        createSiblingNode(node, 1);
                    };
                    nodeEl.appendChild(downControl);
                }
                // No right control for any node with children
                return;
            }

            // Node without children
            if (isRoot) {
                // Root node without children: show right control only
                const rightControl = document.createElement('div');
                rightControl.className = 'hover-control right';
                rightControl.innerHTML = '+';
                rightControl.title = 'Add child node';
                rightControl.onclick = e => {
                    e.stopPropagation();
                    createChildNode(node);
                };
                nodeEl.appendChild(rightControl);
            } else {
                // Non-root node without children: show all three controls
                const rightControl = document.createElement('div');
                rightControl.className = 'hover-control right';
                rightControl.innerHTML = '+';
                rightControl.title = 'Add child node';
                rightControl.onclick = e => {
                    e.stopPropagation();
                    createChildNode(node);
                };
                nodeEl.appendChild(rightControl);

                const upControl = document.createElement('div');
                upControl.className = 'hover-control up';
                upControl.innerHTML = '+';
                upControl.title = 'Add sibling above';
                upControl.onclick = e => {
                    e.stopPropagation();
                    createSiblingNode(node, 0);
                };
                nodeEl.appendChild(upControl);

                const downControl = document.createElement('div');
                downControl.className = 'hover-control down';
                downControl.innerHTML = '+';
                downControl.title = 'Add sibling below';
                downControl.onclick = e => {
                    e.stopPropagation();
                    createSiblingNode(node, 1);
                };
                nodeEl.appendChild(downControl);
            }
        }

        function drawEdge(parent, child) {
            if (!parent.element || !child.element) return;

            const parentRect = parent.element.getBoundingClientRect();
            const childRect = child.element.getBoundingClientRect();
            const containerRect = mindmapInner.getBoundingClientRect();

            // Calculate positions relative to the mindmap container
            const startX = (parentRect.right - containerRect.left) / zoom;
            const startY = (parentRect.top + parentRect.height / 2 - containerRect.top) / zoom;
            const endX = (childRect.left - containerRect.left) / zoom;
            const endY = (childRect.top + childRect.height / 2 - containerRect.top) / zoom;

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const midX = (startX + endX) / 2;
            path.setAttribute('d', `M${startX},${startY} C${midX},${startY} ${midX},${endY} ${endX},${endY}`);
            path.setAttribute('stroke', '#4299e1');
            path.setAttribute('stroke-width', '2');
            path.setAttribute('fill', 'none');
            path.setAttribute('opacity', '0.8');
            path.classList.add('edge');
            canvas.appendChild(path);
        }        // --- Auto arrange (left->right tree, always visible) ---
        function autoArrange(fullRender = false) {
            if (nodes.length === 0) return;
            // Find root(s)
            const roots = nodes.filter(n => !n.parent);

            // If we have existing roots, preserve their viewport position
            let preservedRootPosition = null;
            if (roots.length > 0 && roots[0].element) {
                const rootRect = roots[0].element.getBoundingClientRect();
                const containerRect = mindmapInner.getBoundingClientRect();
                preservedRootPosition = {
                    x: (rootRect.left - containerRect.left) / zoom,
                    y: (rootRect.top - containerRect.top) / zoom
                };
            }
            // Arrange multiple roots with proper spacing on the left side
            const leftMargin = 200; // Consistent left margin
            let currentY = 40;
            roots.forEach(root => {
                const subtreeHeight = measureSubtreeHeight(root);
                if (preservedRootPosition && root === roots[0]) {
                    // Keep first root at its current position
                    arrangeSubtree(root, root.x, root.y, 0);
                } else {
                    // Position other roots with proper spacing, aligned to left margin
                    arrangeSubtree(root, leftMargin, currentY + subtreeHeight / 2, 0);
                }
                currentY += subtreeHeight + 60; // Extra spacing between root trees
            });
            // Don't center the mindmap - let it grow from left to right
            // Only center vertically if this is initial load and no preserved position
            if (!preservedRootPosition && nodes.length > 0) {
                centerMindmapVertically();
            }

            // Use appropriate update method based on whether we need full render
            if (fullRender) {
                scheduleRender();
            } else {
                updatePositionsAndEdges();
            }
        }

        function measureSubtreeHeight(node) {
            if (node.collapsed || node.children.length === 0) return 80;

            // Calculate the height needed for all children
            const childHeights = node.children.map(child => measureSubtreeHeight(child));
            const totalChildHeight = childHeights.reduce((sum, h) => sum + h, 0);
            const spacing = Math.max(20, 80 / node.children.length);
            const totalSpacing = Math.max(0, (node.children.length - 1) * spacing);

            // Return the maximum of node's own height or the total height of its children
            return Math.max(80, totalChildHeight + totalSpacing);
        }

        function arrangeSubtree(node, x, y, level) {
            // Only update position if this is root node being initially placed
            // or if it's a child node (always update children positions)
            if (level > 0 || !node.element) {
                node.x = x;
                node.y = y;
            }

            if (node.collapsed || node.children.length === 0) return;

            // Calculate total height needed for all children
            const childHeights = node.children.map(child => measureSubtreeHeight(child));
            const totalHeight = childHeights.reduce((sum, h) => sum + h, 0);
            const spacing = Math.max(20, 80 / node.children.length); // Dynamic spacing based on number of children

            // Start positioning children from the top of the allocated space
            let currentY = node.y - totalHeight / 2;

            node.children.forEach((child, index) => {
                const childHeight = childHeights[index];
                // Position child at the center of its allocated height
                const childCenterY = currentY + childHeight / 2;
                arrangeSubtree(child, node.x + 280, childCenterY, level + 1);
                // Move to next child's position
                currentY += childHeight + spacing;
            });
        } function centerMindmap() {
            // Compute bounding box of all visible nodes
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            nodes.forEach(n => {
                if (isNodeVisible(n)) {
                    minX = Math.min(minX, n.x);
                    minY = Math.min(minY, n.y);
                    maxX = Math.max(maxX, n.x + 120);
                    maxY = Math.max(maxY, n.y + 40);
                }
            });
            if (minX === Infinity) return;
            const mapW = maxX - minX, mapH = maxY - minY;
            const cx = window.innerWidth / 2, cy = window.innerHeight / 2;
            pan.x = cx - (minX + mapW / 2) * zoom;
            pan.y = cy - (minY + mapH / 2) * zoom;
            applyTransform();
        }

        function centerMindmapVertically() {
            // Only center vertically, keep left alignment
            let minY = Infinity, maxY = -Infinity;
            nodes.forEach(n => {
                if (isNodeVisible(n)) {
                    minY = Math.min(minY, n.y);
                    maxY = Math.max(maxY, n.y + 40);
                }
            });
            if (minY === Infinity) return;
            const mapH = maxY - minY;
            const cy = window.innerHeight / 2;
            pan.y = cy - (minY + mapH / 2) * zoom;
            applyTransform();
        }

        function isNodeVisible(node) {
            if (!node.parent) return true;
            if (node.parent.collapsed) return false;
            return isNodeVisible(node.parent);
        }

        // --- Checkbox functionality ---        
        function toggleNodeCompletion(node) {
            node.completed = !node.completed;
            markAsChanged(); // Mark as changed when completion status changes
            
            // Update the visual state without full re-render
            if (node.element) {
                const checkbox = node.element.querySelector('.node-checkbox');
                const contentWrapper = node.element.querySelector('.node-content');
                
                if (node.completed) {
                    node.element.classList.add('completed');
                    checkbox.classList.add('checked');
                } else {
                    node.element.classList.remove('completed');
                    checkbox.classList.remove('checked');
                }
            }
        }

        // --- Node selection and editing ---
        function selectNode(node) {
            // Only update selection classes, don't re-render
            if (selectedNode && selectedNode.element) {
                selectedNode.element.classList.remove('selected');
            }
            selectedNode = node;
            if (selectedNode && selectedNode.element) {
                selectedNode.element.classList.add('selected');            }
        }
        
        function startEditing(node) {
            if (editingNode === node) return;
            editingNode = node;

            // Don't re-render, just update the node in place
            if (node.element) {
                node.element.classList.add('editing');
                const contentWrapper = node.element.querySelector('.node-content');
                const input = document.createElement('input');
                input.value = node.text;
                input.style.width = '100%';
                input.onkeydown = e => {
                    if (e.key === 'Enter') {
                        stopEditing(node, input.value);
                        e.preventDefault();
                    } else if (e.key === 'Escape') {
                        stopEditing(node, node.text);
                        e.preventDefault();
                    }
                    e.stopPropagation();
                };
                input.onblur = () => stopEditing(node, input.value);
                
                // Replace the content wrapper with input
                contentWrapper.innerHTML = '';
                contentWrapper.appendChild(input);
                input.focus();
                input.select();
            }
        }
        
        function stopEditing(node, value) {
            const oldText = node.text;
            node.text = value.trim() || 'New Idea';
            editingNode = null;

            // Mark as changed if text actually changed
            if (oldText !== node.text) {
                markAsChanged();
            }

            // Don't re-render, just update the node in place
            if (node.element) {
                node.element.classList.remove('editing');

                // Clear all content first
                node.element.innerHTML = '';

                // Re-add checkbox
                const checkbox = document.createElement('div');
                checkbox.className = 'node-checkbox';
                if (node.completed) checkbox.classList.add('checked');
                checkbox.onclick = e => {
                    e.stopPropagation();
                    toggleNodeCompletion(node);
                };
                node.element.appendChild(checkbox);

                // Re-add content wrapper with updated text
                const contentWrapper = document.createElement('span');
                contentWrapper.className = 'node-content';
                contentWrapper.textContent = node.text;
                node.element.appendChild(contentWrapper);                // Update completed state
                if (node.completed) {
                    node.element.classList.add('completed');
                } else {
                    node.element.classList.remove('completed');
                }

                // Adjust width based on text length (account for checkbox width)
                const textLength = node.text.length;
                if (textLength > 12) {
                    node.element.style.width = Math.min(200, Math.max(140, textLength * 8 + 32)) + 'px';
                } else {
                    node.element.style.width = '140px';
                }

                // Re-add expand button if needed
                if (node.children.length > 0) {
                    const btn = document.createElement('button');
                    btn.className = 'expand-btn';
                    btn.textContent = node.collapsed ? '+' : '‚àí';
                    btn.onclick = e => {
                        e.stopPropagation();
                        toggleCollapse(node);
                    };
                    node.element.appendChild(btn);
                    node.expandBtn = btn;
                }// Re-add note indicator - only show when note exists
                if (node.note && node.note.trim()) {
                    const noteIndicator = document.createElement('div');
                    noteIndicator.className = 'note-indicator has-note';
                    noteIndicator.innerHTML = 'üìù';
                    // Show note text in tooltip, truncate if too long
                    const notePreview = node.note.length > 100 ? node.note.substring(0, 100) + '...' : node.note;
                    noteIndicator.title = `Note: ${notePreview}\n\nClick to edit`;
                    noteIndicator.onclick = e => {
                        e.stopPropagation();
                        openNoteModal(node);
                    };
                    node.element.appendChild(noteIndicator);
                }

                // Re-add hover controls
                addHoverControls(node.element, node);
            }
        }

        // --- Expand/collapse ---
        function toggleCollapse(node) {
            node.collapsed = !node.collapsed;
            // Update button without re-rendering
            if (node.expandBtn) {
                node.expandBtn.textContent = node.collapsed ? '+' : '‚àí';
            }

            // Hide/show children without full re-render
            if (node.collapsed) {
                // Hide all descendants
                hideDescendants(node);
            } else {
                // Show immediate children (they might have their own collapsed state)
                showChildren(node);
            }              // Rearrange positions and redraw edges
            const roots = nodes.filter(n => !n.parent);
            const leftMargin = 200; // Use consistent left margin
            let y = 0;
            roots.forEach(root => {
                const subtreeHeight = measureSubtreeHeight(root);
                arrangeSubtree(root, leftMargin, y + 40, 0);
                y += subtreeHeight + 40;
            });

            // Use efficient update to prevent flickering
            updatePositionsAndEdges();
        }

        function hideDescendants(node) {
            node.children.forEach(child => {
                if (child.element) {
                    child.element.style.display = 'none';
                }
                hideDescendants(child);
            });
        }

        function showChildren(node) {
            node.children.forEach(child => {
                if (child.element) {
                    child.element.style.display = 'flex';
                }
                if (!child.collapsed) {
                    showChildren(child);
                }
            });
        }        // --- Delete functionality ---
        function deleteNode(node) {
            if (!node) return;

            // Always show confirmation dialog for all nodes
            nodeToDelete = node;
            const childCount = countAllDescendants(node);

            // Update the confirmation message based on whether there are children
            const confirmDialog = document.getElementById('delete-confirm');
            const messageElement = confirmDialog.querySelector('p');

            if (node.children.length > 0) {
                messageElement.innerHTML = `This node has <span id="child-count">${childCount}</span> child node(s). Delete the entire branch?`;
            } else {
                messageElement.textContent = 'Are you sure you want to delete this node?';
            }

            document.getElementById('overlay').classList.remove('hidden');
            document.getElementById('delete-confirm').classList.remove('hidden');

            // Focus on cancel button for better accessibility
            setTimeout(() => {
                const cancelBtn = document.querySelector('.delete-confirm .cancel-btn');
                if (cancelBtn) cancelBtn.focus();
            }, 10);
        }

        function countAllDescendants(node) {
            let count = node.children.length;
            node.children.forEach(child => {
                count += countAllDescendants(child);
            });
            return count;
        }
        
        function performDelete(node) {
            markAsChanged(); // Mark as changed when deleting nodes
            
            // Select another node before deletion
            let newSelection = null;
            if (node.parent) {
                const siblings = node.parent.children;
                const index = siblings.indexOf(node);
                if (index > 0) {
                    newSelection = siblings[index - 1];
                } else if (index < siblings.length - 1) {
                    newSelection = siblings[index + 1];
                } else {
                    newSelection = node.parent;
                }
            } else {
                // Deleting root, select another root if available
                const roots = nodes.filter(n => !n.parent);
                const rootIndex = roots.indexOf(node);
                if (roots.length > 1) {
                    newSelection = roots[rootIndex === 0 ? 1 : 0];
                }
            }

            // Remove from parent's children
            if (node.parent) {
                const index = node.parent.children.indexOf(node);
                if (index > -1) {
                    node.parent.children.splice(index, 1);
                }

                // Remove expand button if parent now has no children
                if (node.parent.children.length === 0 && node.parent.expandBtn) {
                    node.parent.expandBtn.remove();
                    node.parent.expandBtn = null;
                }
            }            // Remove node and all descendants from nodes array
            const toRemove = [node];
            const collectDescendants = (n) => {
                n.children.forEach(child => {
                    toRemove.push(child);
                    collectDescendants(child);
                });
            };
            collectDescendants(node);
            // Remove DOM elements immediately
            toRemove.forEach(n => {
                if (n.element) {
                    n.element.remove();
                    n.element = null;
                }
                const index = nodes.indexOf(n);
                if (index > -1) {
                    nodes.splice(index, 1);
                }
            });

            // Clear all edges before rearranging to avoid orphaned edges
            const edges = canvas.querySelectorAll('.edge');
            edges.forEach(edge => edge.remove());

            // Select new node
            if (newSelection) {
                selectNode(newSelection);
            } else {
                selectedNode = null;
            }

            // Re-arrange and render
            autoArrange();
        }

        function confirmDelete() {
            if (nodeToDelete) {
                performDelete(nodeToDelete);
                cancelDelete();
            }
        }

        function cancelDelete() {
            nodeToDelete = null;
            document.getElementById('overlay').classList.add('hidden');
            document.getElementById('delete-confirm').classList.add('hidden');
        }

        // --- Context Menu functionality ---
        let contextMenu = null;

        function showContextMenu(e, node) {
            // Remove existing context menu if any
            hideContextMenu();

            // Create context menu
            contextMenu = document.createElement('div');
            contextMenu.className = 'context-menu';

            // Add note option (only show if node doesn't have a note)
            if (!node.note || !node.note.trim()) {
                const addNoteItem = document.createElement('div');
                addNoteItem.className = 'context-menu-item';
                addNoteItem.innerHTML = 'üìù Add note';
                addNoteItem.onclick = () => {
                    hideContextMenu();
                    openNoteModal(node);
                };
                contextMenu.appendChild(addNoteItem);
            } else {
                const editNoteItem = document.createElement('div');
                editNoteItem.className = 'context-menu-item';
                editNoteItem.innerHTML = 'üìù Edit note';
                editNoteItem.onclick = () => {
                    hideContextMenu();
                    openNoteModal(node);
                };
                contextMenu.appendChild(editNoteItem);
            }

            // Position context menu
            document.body.appendChild(contextMenu);

            // Calculate position to keep menu within viewport
            const menuRect = contextMenu.getBoundingClientRect();
            let x = e.clientX;
            let y = e.clientY;

            if (x + menuRect.width > window.innerWidth) {
                x = window.innerWidth - menuRect.width - 10;
            }
            if (y + menuRect.height > window.innerHeight) {
                y = window.innerHeight - menuRect.height - 10;
            }

            contextMenu.style.left = x + 'px';
            contextMenu.style.top = y + 'px';
        }

        function hideContextMenu() {
            if (contextMenu) {
                contextMenu.remove();
                contextMenu = null;
            }
        }

        // Hide context menu when clicking elsewhere
        document.addEventListener('click', hideContextMenu);
        document.addEventListener('contextmenu', (e) => {
            // Only prevent default context menu on nodes, allow it elsewhere
            if (!e.target.closest('.node')) {
                hideContextMenu();
            }
        });

        // --- Note functionality ---
        function openNoteModal(node) {
            currentNoteNode = node;
            const modal = document.getElementById('note-modal');
            const textarea = document.getElementById('note-textarea');
            const deleteBtn = document.getElementById('note-delete-btn');

            textarea.value = node.note || '';

            // Show/hide delete button based on whether note exists
            if (node.note && node.note.trim()) {
                deleteBtn.style.display = 'inline-block';
            } else {
                deleteBtn.style.display = 'none';
            }

            modal.classList.remove('hidden');
            document.getElementById('overlay').classList.remove('hidden');

            // Add keyboard handler for the textarea
            textarea.onkeydown = (e) => {
                if (e.key === 'Escape') {
                    closeNoteModal();
                    e.preventDefault();
                } else if (e.ctrlKey && e.key === 'Enter') {
                    saveNote();
                    e.preventDefault();
                }
                e.stopPropagation();
            };

            setTimeout(() => {
                textarea.focus();
                textarea.select();
            }, 100);
        } function closeNoteModal() {
            const modal = document.getElementById('note-modal');
            const textarea = document.getElementById('note-textarea');
            modal.classList.add('hidden');
            document.getElementById('overlay').classList.add('hidden');

            // Remove the keyboard handler
            textarea.onkeydown = null;
            currentNoteNode = null;
        }
        
        function saveNote() {
            if (currentNoteNode) {
                const textarea = document.getElementById('note-textarea');
                const oldNote = currentNoteNode.note;
                currentNoteNode.note = textarea.value.trim();
                
                // Mark as changed if note actually changed
                if (oldNote !== currentNoteNode.note) {
                    markAsChanged();
                }
                
                render();  // Re-render to update note indicators
                closeNoteModal();
            }
        }
        
        function deleteNote() {
            if (currentNoteNode) {
                const oldNote = currentNoteNode.note;
                currentNoteNode.note = '';
                
                // Mark as changed if note was actually deleted
                if (oldNote) {
                    markAsChanged();
                }
                
                render();  // Re-render to update note indicators
                closeNoteModal();
            }
        }
        
        // Make functions globally accessible for onclick handlers
        window.closeNoteModal = closeNoteModal;
        window.saveNote = saveNote;
        window.deleteNote = deleteNote;
        window.saveMindMapAsMarkdown = saveMindMapAsMarkdown;
        window.saveMindMapAsNewFile = saveMindMapAsNewFile; // Expose the new function
        window.loadMindMapFromMarkdown = loadMindMapFromMarkdown;
        window.toggleInstructions = toggleInstructions;
        window.cancelDelete = cancelDelete;
        window.confirmDelete = confirmDelete;

        let currentFileHandle = null; // Added to store the file handle for File System Access API
        let hasUnsavedChanges = false; // Track unsaved changes
        let currentFileName = null; // Track current file name

        // File status functions
        function updateFileStatus() {
            const fileStatusEl = document.getElementById('file-status');
            const fileNameEl = document.getElementById('file-name');
            const unsavedIndicatorEl = document.getElementById('unsaved-indicator');

            if (currentFileName) {
                fileStatusEl.classList.remove('no-file');
                fileNameEl.textContent = currentFileName;
                unsavedIndicatorEl.style.display = hasUnsavedChanges ? 'inline' : 'none';
            } else {
                fileStatusEl.classList.add('no-file');
                fileNameEl.textContent = 'Untitled';
                unsavedIndicatorEl.style.display = hasUnsavedChanges ? 'inline' : 'none';
            }
        }

        function markAsChanged() {
            if (!hasUnsavedChanges) {
                hasUnsavedChanges = true;
                updateFileStatus();
            }
        }

        function markAsSaved() {
            hasUnsavedChanges = false;
            updateFileStatus();
        }

        function setCurrentFile(fileName) {
            currentFileName = fileName;
            hasUnsavedChanges = false;
            updateFileStatus();
        }

// --- Keyboard controls ---
        document.addEventListener('keydown', e => {
            // Handle escape key for note modal
            if (!document.getElementById('note-modal').classList.contains('hidden')) {
                if (e.key === 'Escape') {
                    closeNoteModal();
                    e.preventDefault();
                }
                return; // Don't process other keys when note modal is open
            }

            // Handle escape key for delete confirmation
            if (!document.getElementById('delete-confirm').classList.contains('hidden')) {
                if (e.key === 'Escape') {
                    cancelDelete();
                    e.preventDefault();
                }
                return; // Don't process other keys when dialog is open
            }

            // Handle Ctrl+S for saving
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                saveMindMapAsMarkdown();
                return;
            }

            if (nodes.length === 0 && e.key === 'Enter') {
                createFirstNode({ clientX: window.innerWidth / 2, clientY: window.innerHeight / 2 });
                return;
            }
            if (!selectedNode) return;

            // Editing - only handle if selected
            if (e.key === 'Enter' && !e.ctrlKey) {
                if (editingNode === selectedNode) {
                    // If already editing, Enter will be handled by input's keydown
                    return;
                } else {
                    startEditing(selectedNode);
                    e.preventDefault();
                    return;
                }
            }

            // Don't handle other keys while editing
            if (editingNode) return;            // Delete key
            if (e.key === 'Delete') {
                if (selectedNode) {
                    deleteNode(selectedNode);
                    e.preventDefault();
                }
                return;
            }            // Note key (N)
            if (e.key === 'n' || e.key === 'N') {
                if (selectedNode) {
                    openNoteModal(selectedNode);
                    e.preventDefault();
                }
                return;
            }

            // Checkbox toggle key (Space)
            if (e.key === ' ') {
                if (selectedNode) {
                    toggleNodeCompletion(selectedNode);
                    e.preventDefault();
                }
                return;
            }

            // Navigation
            if (!e.ctrlKey) {
                if (e.key === 'ArrowRight') {
                    // Go to nearest child
                    if (!selectedNode.collapsed && selectedNode.children.length > 0) {
                        // Find child closest to current Y position
                        let closestChild = selectedNode.children[0];
                        let minDistance = Math.abs(closestChild.y - selectedNode.y);

                        selectedNode.children.forEach(child => {
                            const distance = Math.abs(child.y - selectedNode.y);
                            if (distance < minDistance) {
                                minDistance = distance;
                                closestChild = child;
                            }
                        });
                        selectNode(closestChild);
                    }
                } else if (e.key === 'ArrowLeft') {
                    // Always go to parent
                    if (selectedNode.parent) selectNode(selectedNode.parent);
                } else if (e.key === 'ArrowUp') {
                    // Strictly vertical up - find node directly above
                    const targetNode = findNodeVertically(selectedNode, 'up');
                    if (targetNode) selectNode(targetNode);
                } else if (e.key === 'ArrowDown') {
                    // Strictly vertical down - find node directly below
                    const targetNode = findNodeVertically(selectedNode, 'down');
                    if (targetNode) selectNode(targetNode);
                }
            }

            // Structure changes
            if (e.ctrlKey) {
                if (e.key === 'ArrowRight') {
                    if (selectedNode.collapsed) {
                        selectedNode.collapsed = false;
                        // Just update the button without full re-render
                        if (selectedNode.expandBtn) {
                            selectedNode.expandBtn.textContent = '‚àí';
                        }
                        autoArrange();
                        // Focus on first child after expanding
                        if (selectedNode.children.length > 0) {
                            setTimeout(() => {
                                selectNode(selectedNode.children[0]);
                            }, 50);
                        }
                    } else {
                        createChildNode(selectedNode);
                    }
                    e.preventDefault();
                } else if (e.key === 'ArrowLeft') {
                    // Collapse current node if it has children, otherwise collapse parent
                    if (selectedNode.children.length > 0) {
                        // Current node has children
                        if (!selectedNode.collapsed) {
                            // Not collapsed - collapse it
                            selectedNode.collapsed = true;
                            // Update button without full re-render
                            if (selectedNode.expandBtn) {
                                selectedNode.expandBtn.textContent = '+';
                            }
                            // Hide descendants and update positions efficiently
                            hideDescendants(selectedNode);
                            autoArrange();
                        } else if (selectedNode.parent && selectedNode.parent.children.length > 0) {
                            // Already collapsed - collapse parent if it has children
                            if (!selectedNode.parent.collapsed) {
                                selectedNode.parent.collapsed = true;
                                selectNode(selectedNode.parent);
                                // Update button without full re-render
                                if (selectedNode.expandBtn) {
                                    selectedNode.expandBtn.textContent = '+';
                                }
                                hideDescendants(selectedNode);
                                autoArrange();
                            }
                        }
                    } else if (selectedNode.parent && selectedNode.parent.children.length > 0) {
                        // No children, but parent has children - collapse parent and select it
                        if (!selectedNode.parent.collapsed) {
                            selectedNode.parent.collapsed = true;
                            selectNode(selectedNode.parent);
                            // Update button without full re-render
                            if (selectedNode.expandBtn) {
                                selectedNode.expandBtn.textContent = '+';
                            }
                            hideDescendants(selectedNode);
                            autoArrange();
                        }
                    }
                    e.preventDefault();
                } else if (e.key === 'ArrowDown') {
                    if (selectedNode.parent) {
                        createSiblingNode(selectedNode, 1);
                    }
                    e.preventDefault();
                } else if (e.key === 'ArrowUp') {
                    if (selectedNode.parent) {
                        createSiblingNode(selectedNode, 0);
                    }
                    e.preventDefault();
                }
            }
        }, true); // MODIFIED: Added true for capturing phase to handle Ctrl+S during input focus

        function getVisibleSiblings(node) {
            if (!node.parent) return [node];
            return node.parent.children;
        }

        function findNodeInDirection(fromNode, direction) {
            // Get all visible nodes
            const visibleNodes = [];
            nodes.forEach(node => {
                if (isNodeVisible(node)) {
                    visibleNodes.push(node);
                }
            });

            // Sort by Y position
            visibleNodes.sort((a, b) => a.y - b.y);

            // Find nodes in the target direction
            const currentY = fromNode.y;
            const currentX = fromNode.x;
            let candidates = [];

            if (direction === 'up') {
                candidates = visibleNodes.filter(n => n.y < currentY - 10);
                candidates.sort((a, b) => b.y - a.y); // Closest first
            } else {
                candidates = visibleNodes.filter(n => n.y > currentY + 10);
                candidates.sort((a, b) => a.y - b.y); // Closest first
            }

            // Find the best candidate (closest in X direction among the closest in Y)
            if (candidates.length > 0) {
                // Group by similar Y position (within 30px)
                const firstY = candidates[0].y;
                const similarY = candidates.filter(n => Math.abs(n.y - firstY) < 30);

                // Among those, find closest X
                similarY.sort((a, b) => Math.abs(a.x - currentX) - Math.abs(b.x - currentX));
                return similarY[0];
            }

            return null;
        }

        function findNodeVertically(fromNode, direction) {
            // Get all visible nodes at the same generation level (siblings and cousins)
            const visibleNodes = [];
            const fromLevel = getNodeLevel(fromNode);

            nodes.forEach(node => {
                if (isNodeVisible(node) && node !== fromNode && getNodeLevel(node) === fromLevel) {
                    visibleNodes.push(node);
                }
            });

            const currentY = fromNode.y;

            // Filter nodes in the target direction
            let candidates = [];
            if (direction === 'up') {
                candidates = visibleNodes.filter(n => n.y < currentY);
                candidates.sort((a, b) => b.y - a.y); // Sort by Y descending (closest first)
            } else {
                candidates = visibleNodes.filter(n => n.y > currentY);
                candidates.sort((a, b) => a.y - b.y); // Sort by Y ascending (closest first)
            }

            // Return the closest node vertically
            if (candidates.length > 0) {
                return candidates[0];
            }

            return null;
        }

        function getNodeLevel(node) {
            let level = 0;
            let current = node;
            while (current.parent) {
                level++;
                current = current.parent;
            }
            return level;
        }

        function createChildNode(parent) {
            if (parent.collapsed) {
                parent.collapsed = false;
                // Update button without re-rendering
                if (parent.expandBtn) {
                    parent.expandBtn.textContent = '‚àí';
                }
            }
            const node = createNode('New Node', 0, 0, parent);

            // If parent didn't have children before, it needs an expand button now
            if (parent.children.length === 1 && parent.element && !parent.expandBtn) {
                const btn = document.createElement('button');
                btn.className = 'expand-btn';
                btn.textContent = '‚àí';
                btn.onclick = e => {
                    e.stopPropagation();
                    toggleCollapse(parent);
                };
                parent.element.appendChild(btn);
                parent.expandBtn = btn;
            }            // Efficient incremental update after adding child
            autoArrange();
            // Render the newly created child node
            renderSubtree(node);
            // Draw the edge connecting parent to the new node
            drawEdge(parent, node);
            // Smoothly update positions and edges
            updatePositionsAndEdges();
            // Select and start editing after positions update
            setTimeout(() => {
                selectNode(node);
                startEditing(node);
            }, 50);
        }

        function createSiblingNode(node, below = 1) {
            if (!node.parent) return;
            const parent = node.parent;
            const idx = parent.children.indexOf(node);
            const newNode = createNode('New Node', 0, 0, parent);
            parent.children.splice(parent.children.indexOf(newNode), 1); // Remove from end
            parent.children.splice(idx + below, 0, newNode);            // Efficient incremental update after adding sibling
            autoArrange();
            // Render the newly created sibling node
            renderSubtree(newNode);
            // Draw the edge connecting parent to the new sibling
            drawEdge(parent, newNode);
            // Smoothly update positions and edges
            updatePositionsAndEdges();

            // Select and start editing after positions update
            setTimeout(() => {
                selectNode(newNode);
                startEditing(newNode);
            }, 50);
        }

        // --- Save/Load ---
        // Remove saveMindMap and loadMindMap functions

        // --- Markdown Save/Load ---
        async function saveMindMapAsMarkdown() {
            try {
                // Find root nodes
                const roots = nodes.filter(n => !n.parent);
                let markdown = '# Mind Map\n\n'; // Corrected: Use actual newline characters

                // Convert tree to markdown
                roots.forEach(root => {
                    markdown += nodeToMarkdown(root, 0);
                });

                if (!window.showSaveFilePicker) {
                    alert('File System Access API is not supported in this browser. Falling back to download.');
                    // Fallback to old method
                    const blob = new Blob([markdown], { type: 'text/markdown' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'mindmap.md';
                    a.click();
                    URL.revokeObjectURL(url);
                    return;
                }

                if (!currentFileHandle) {
                    currentFileHandle = await window.showSaveFilePicker({
                        suggestedName: 'mindmap.md',
                        types: [{
                            description: 'Markdown Files',
                            accept: { 'text/markdown': ['.md'] },
                        }],
                    });
                }                const writable = await currentFileHandle.createWritable();
                await writable.write(markdown);
                await writable.close();
                
                // Update file status after successful save
                if (currentFileHandle.name) {
                    setCurrentFile(currentFileHandle.name);
                } else {
                    markAsSaved();
                }
                
                showSaveNotification(currentFileHandle.name); // Show notification
            } catch (err) {
                if (err.name === 'AbortError') {
                    // User cancelled the file picker
                    console.log('Save operation cancelled by user.');
                } else {
                    console.error('Error saving mind map:', err);
                    alert('Error saving mind map: ' + err.message);
                    // Invalidate the handle on other errors so the user is prompted again
                    currentFileHandle = null;
                }
            }
        }        async function saveMindMapAsNewFile() {
            const oldFileHandle = currentFileHandle; // Temporarily store the old handle
            currentFileHandle = null; // Force showSaveFilePicker to always ask for a new file
            try {
                await saveMindMapAsMarkdown(); // This will now prompt for a new file location
                // If we reach here, save was successful, so don't restore old handle
            } catch (err) {
                // If saveMindMapAsMarkdown fails (e.g., user cancels), restore the old handle
                currentFileHandle = oldFileHandle;
                // Error is already handled and logged by saveMindMapAsMarkdown, so just rethrow or log here if needed
                console.error('Error during "Save As":', err);
                // Potentially alert the user if saveMindMapAsMarkdown doesn't already
            }
            
            // If currentFileHandle is still null after saveMindMapAsMarkdown (user cancelled),
            // restore the old handle
            if (currentFileHandle === null) {
                currentFileHandle = oldFileHandle;
            }
        }

        function nodeToMarkdown(node, level) {
            let markdown = '';
            const indent = '  '.repeat(level);
            const checkbox = node.completed ? '[x]' : '[ ]';
            markdown += indent + '- ' + checkbox + ' ' + node.text + '\n'; // Corrected

            // Add note if it exists
            if (node.note && node.note.trim()) {
                const noteLines = node.note.trim().split('\n'); // Corrected
                noteLines.forEach(line => {
                    markdown += indent + '  > ' + line + '\n'; // Corrected
                });
            }

            // Always include children regardless of collapsed state
            node.children.forEach(child => {
                markdown += nodeToMarkdown(child, level + 1);
            });

            return markdown;
        }

        async function loadMindMapFromMarkdown() { // Changed to async function
            if (window.showOpenFilePicker) {
                try {
                    const [fileHandle] = await window.showOpenFilePicker({
                        types: [{
                            description: 'Markdown Files',
                            accept: { 'text/markdown': ['.md', '.markdown'] },
                        }],
                        multiple: false,
                    });
                    const file = await fileHandle.getFile();
                    const markdown = await file.text();
                    console.log('Loading markdown file (via File System Access API)...', markdown.substring(0, 200) + '...');                    parseMarkdownToMindMap(markdown);
                    currentFileHandle = fileHandle; // Store the handle for future saves
                    
                    // Update file status after successful load
                    setCurrentFile(fileHandle.name);
                    
                    console.log('Loaded', nodes.length, 'nodes. File handle stored.');
                } catch (err) {
                    if (err.name === 'AbortError') {
                        console.log('File open operation cancelled by user.');
                    } else {
                        console.error('Error loading markdown via File System Access API:', err);
                        alert('Error loading markdown: ' + err.message);
                    }
                }
            } else {
                // Fallback to input element if File System Access API is not supported
                alert('File System Access API is not supported for opening. Falling back to standard file input.');
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.md,.markdown';
                input.onchange = e => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = re => {
                            try {
                                console.log('Loading markdown file (via input)...', re.target.result.substring(0, 200) + '...');                                parseMarkdownToMindMap(re.target.result);
                                currentFileHandle = null; // Ensure handle is cleared if using fallback
                                
                                // Update file status for fallback load (no file handle)
                                setCurrentFile(file.name);
                                
                                console.log('Loaded', nodes.length, 'nodes');
                            } catch (err) {
                                console.error('Error loading markdown:', err);
                                alert('Error loading markdown: ' + err.message);
                            }
                        };
                        reader.readAsText(file);
                    }
                };
                input.click();
            }
        }
        
        function parseMarkdownToMindMap(markdown) {
            console.log('Parsing markdown:', markdown.substring(0, 100) + '...');
            
            // Clear existing DOM elements before clearing the nodes array
            nodes.forEach(node => {
                if (node.element) {
                    node.element.remove();
                    node.element = null;
                }
            });
            
            // Clear all edges from the canvas
            const edges = canvas.querySelectorAll('.edge');
            edges.forEach(edge => edge.remove());
            
            nodes = [];
            selectedNode = null;
            nextId = 1;

            // Extract metadata and collapsed state - removed per user request
            // Parse markdown lines - handle both CRLF and LF line endings
            const lines = markdown.replace(/\r\n/g, '\n').split('\n');
            const nodeStack = [];
            let currentNode = null;
            lines.forEach(line => {
                // Skip empty lines and metadata
                if (!line.trim() || line.startsWith('<!--') || line.startsWith('#')) return;

                console.log('Processing line:', line);
                // Check if this is a note line (indented >)
                const noteMatch = line.match(/^(\s*)>\s*(.*)$/);
                if (noteMatch) {
                    const noteIndent = noteMatch[1].length / 2;
                    const noteText = noteMatch[2];

                    // Find the node this note belongs to based on indentation
                    let targetNode = null;
                    if (noteIndent === 0) {
                        // Note at root level - find the last root node
                        for (let i = nodes.length - 1; i >= 0; i--) {
                            if (!nodes[i].parent) {
                                targetNode = nodes[i];
                                break;
                            }
                        }
                    } else {
                        // Note is indented - find the node at the parent level
                        const parentLevel = noteIndent - 1;
                        for (let i = nodeStack.length - 1; i >= 0; i--) {
                            if (nodeStack[i].level === parentLevel) {
                                targetNode = nodeStack[i].node;
                                break;
                            }
                        }
                    }

                    if (targetNode) {
                        if (targetNode.note) {
                            targetNode.note += '\n' + noteText;
                        } else {
                            targetNode.note = noteText;
                        }
                        console.log('Added note to:', targetNode.text, 'note:', noteText);
                    } else {
                        console.warn('Could not find target node for note:', noteText, 'at indent:', noteIndent);
                    }
                    return;
                }                // Count indentation (2 spaces per level)
                const indentMatch = line.match(/^(\s*)-\s*(\[[x\s]\])?\s*(.+)$/);
                if (indentMatch) {
                    const indent = indentMatch[1].length / 2;
                    const checkboxMatch = indentMatch[2];
                    const text = indentMatch[3].trim();
                    
                    // Determine completion status from checkbox
                    const completed = checkboxMatch && checkboxMatch.includes('x');
                    
                    // Find parent based on indentation
                    let parent = null;
                    if (indent > 0 && nodeStack.length > 0) {
                        // Find the most recent node at the parent level (indent - 1)
                        for (let i = nodeStack.length - 1; i >= 0; i--) {
                            if (nodeStack[i].level === indent - 1) {
                                parent = nodeStack[i].node;
                                break;
                            }
                        }
                    }
                    
                    // Create node
                    const node = createNode(text, 0, 0, parent);
                    node.completed = completed; // Set completion status
                    currentNode = node;
                    
                    // Update stack - remove all nodes at same or deeper level first
                    while (nodeStack.length > 0 &&
                        nodeStack[nodeStack.length - 1].level >= indent) {
                        nodeStack.pop();
                    }

                    // Now add the current node
                    nodeStack.push({ node, level: indent });
                }
            });

            console.log('Finished parsing. Created', nodes.length, 'nodes');
            autoArrange(true); // Force full render since nodes don't have DOM elements yet
            if (nodes.length > 0) selectNode(nodes[0]);
        }

        // --- UI Functions ---
        function showSaveNotification(fileName) {
            const notification = document.getElementById('save-notification') || createSaveNotificationElement();
            notification.textContent = `Saved to ${fileName}`;
            notification.classList.add('show');

            // Hide after a few seconds
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000); // Adjust time as needed (3 seconds)
        }

        function createSaveNotificationElement() {
            const notification = document.createElement('div');
            notification.id = 'save-notification';
            document.body.appendChild(notification);
            return notification;
        }

        function toggleInstructions() {
            const instructions = document.getElementById('instructions');
            instructions.classList.toggle('collapsed');
            instructions.classList.toggle('expanded');
        }        // --- Initial ---
        canvasContainer.style.cursor = 'grab';
        window.addEventListener('resize', () => {
            autoArrange();
        });

        // Ensure modals are hidden on load
        document.getElementById('note-modal').classList.add('hidden');
        document.getElementById('overlay').classList.add('hidden');
        document.getElementById('delete-confirm').classList.add('hidden');        // Initial render
        scheduleRender();
        
        // Initialize file status display
        updateFileStatus();
    </script>
</body>

</html>