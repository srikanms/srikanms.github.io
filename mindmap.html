<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #ffffff;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }        .toolbar {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .file-status {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 13px;
            color: #4a5568;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 6px;
            max-width: 300px;
            min-width: 120px;
        }

        .file-status .file-icon {
            font-size: 14px;
        }

        .file-status .file-name {
            font-weight: 500;
            color: #2d3748;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex: 1;
        }

        .file-status .unsaved-indicator {
            color: #e53e3e;
            font-weight: bold;
            font-size: 16px;
            margin-left: 2px;
        }

        .file-status.no-file {
            opacity: 0.7;
            font-style: italic;
        }

        .toolbar button {
            padding: 10px 16px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background: #ffffff;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            color: #4a5568;
        }

        .toolbar button:hover {
            background: #f7fafc;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border-color: #cbd5e0;
        }

        #autosave-toggle {
            transition: all 0.3s ease;
        }

        #autosave-toggle:hover {
            background: #f7fafc;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border-color: #cbd5e0;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            cursor: grab;
            background: #ffffff;
        }

        #canvas-container:active {
            cursor: grabbing;
        }

        #mindmap-inner {
            position: absolute;
            top: 0;
            left: 0;
            will-change: transform;
            width: 100%;
            height: 100%;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: visible;
        }        .node {
            position: absolute;
            min-width: 120px;
            max-width: 200px;
            min-height: 40px;
            background: #ffffff;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            cursor: pointer;
            transition: border-color 0.3s ease, background-color 0.3s ease, box-shadow 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            font-size: 14px;
            font-weight: 500;
            color: #2d3748;
            padding: 8px 16px;
            text-align: left;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            z-index: 10;
            white-space: pre-wrap;
            line-height: 1.3;
        }

        .node:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border-color: #cbd5e0;
        }

        .node.selected {
            border-color: #4299e1;
            background: #ebf8ff;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.3);
        }

        /* When node is selected and has status, preserve status color but add selection border */
        .node.selected.status-idea { background-color: #FFF7AE; }
        .node.selected.status-planned { background-color: #FCECC2; }
        .node.selected.status-not-started { background-color: #ECECEC; }
        .node.selected.status-in-progress { background-color: #B8E4F8; }
        .node.selected.status-waiting { background-color: #FFE1C6; }
        .node.selected.status-blocked { background-color: #FFCACA; }
        .node.selected.status-at-risk { background-color: #FFD6C8; }
        .node.selected.status-in-review { background-color: #DAD5F2; }
        .node.selected.status-completed { background-color: #CFF5D1; }
        .node.selected.status-archived { background-color: #D7D7D7; }

        .node.editing {
            background: #ffffff;
            border-color: #4299e1;
        }        .node input {
            border: none;
            outline: none;
            background: transparent;
            font-size: 14px;
            font-weight: 500;
            color: #2d3748;
            text-align: left;
            width: 100%;
            min-width: 100px;
            flex: 1;
        }

        .expand-btn {
            position: absolute;
            right: -12px;
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 24px;
            border: 1px solid #e2e8f0;
            border-radius: 50%;
            background: #4299e1;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
            z-index: 20;
        }

        .expand-btn:hover {
            background: #3182ce;
            transform: translateY(-50%) scale(1.1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .edge {
            position: absolute;
            pointer-events: none;
            z-index: 1;
        }

        .instructions {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(45, 55, 72, 0.95);
            color: white;
            border-radius: 8px;
            font-size: 12px;
            max-width: 320px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .instructions.collapsed {
            cursor: pointer;
            padding: 10px 15px;
        }

        .instructions.expanded {
            padding: 15px;
        }

        .instructions-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .instructions.collapsed .instructions-header {
            margin-bottom: 0;
        }

        .instructions-content {
            display: block;
        }

        .instructions.collapsed .instructions-content {
            display: none;
        }

        .instructions-toggle {
            font-size: 14px;
            opacity: 0.8;
            transition: transform 0.3s ease;
        }

        .instructions.collapsed .instructions-toggle {
            transform: rotate(-90deg);
        }

        .instructions-hint {
            font-size: 11px;
            opacity: 0.7;
            margin-left: 8px;
        }

        .instructions.expanded .instructions-hint {
            display: none;
        }

        .instructions div {
            margin-bottom: 5px;
        }

        .delete-confirm {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            min-width: 300px;
            text-align: center;
        }

        /* Note delete confirmation should appear above note modal */
        .delete-note-confirm {
            z-index: 2002;
        }

        /* Disable note modal interaction when confirmation dialog is open */
        .note-modal.disabled {
            pointer-events: none;
            opacity: 0.5;
        }

        .delete-confirm h3 {
            margin: 0 0 10px 0;
            color: #2d3748;
        }

        .delete-confirm p {
            margin: 0 0 20px 0;
            color: #718096;
            font-size: 14px;
        }

        .delete-confirm-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .delete-confirm button {
            padding: 8px 20px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .delete-confirm .confirm-btn {
            background: #e53e3e;
            color: white;
            border-color: #e53e3e;
        }

        .delete-confirm .confirm-btn:hover {
            background: #c53030;
            border-color: #c53030;
        }

        .delete-confirm .cancel-btn {
            background: white;
            color: #4a5568;
        }

        .delete-confirm .cancel-btn:hover {
            background: #f7fafc;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            z-index: 1999;
        }

        .hidden {
            display: none !important;
        }        /* Checkbox styles */
        .node-checkbox {
            width: 16px;
            height: 16px;
            border: 2px solid #cbd5e0;
            border-radius: 3px;
            background: #ffffff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
            margin-right: 8px;
        }

        .node-checkbox:hover {
            border-color: #4299e1;
            background: #f7fafc;
        }

        .node-checkbox.checked {
            background: #4299e1;
            border-color: #4299e1;
            color: white;
        }

        .node-checkbox.checked::after {
            content: '✓';
            font-size: 12px;
            font-weight: bold;
        }

        .node.completed {
            opacity: 0.7;
        }        .node.completed .node-content {
            text-decoration: line-through;
            color: #718096;
        }

        .node-content {
            flex: 1;
            text-align: left;
        }

        /* Note feature styles - only show when note exists */
        .note-indicator {
            position: absolute;
            top: -12px;
            left: -12px;
            width: 22px;
            height: 22px;
            background: rgba(255, 255, 255, 1);
            border: 1px solid #e2e8f0;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            color: #718096;
            z-index: 25;
            transition: all 0.3s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        }

        .note-indicator:hover {
            transform: scale(1.1);
            background: rgba(255, 255, 255, 1);
            border-color: #cbd5e0;
            color: #4a5568;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12);
        }

        /* Context menu styles */
        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15);
            z-index: 3000;
            min-width: 150px;
            padding: 8px 0;
            font-size: 14px;
        }

        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .context-menu-item:hover {
            background: #f7fafc;
        }

        .context-menu-item.disabled {
            color: #a0aec0;
            cursor: not-allowed;
        }

        .context-menu-item.disabled:hover {
            background: transparent;
        }

        .context-menu-separator {
            height: 1px;
            background: #e2e8f0;
            margin: 4px 0;
        }

        .context-menu-item.delete {
            color: #e53e3e;
        }

        .context-menu-item.delete:hover {
            background: #fed7d7;
        }

        .note-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
            z-index: 2001;
            min-width: 400px;
            max-width: 600px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }

        .note-modal-header {
            padding: 20px 20px 10px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .note-modal-header h3 {
            margin: 0;
            color: #2d3748;
            font-size: 18px;
        }

        .note-modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #718096;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .note-modal-close:hover {
            background: #f7fafc;
            color: #2d3748;
        }

        .note-modal-body {
            padding: 20px;
            flex: 1;
            overflow-y: auto;
        }

        .note-textarea {
            width: 100%;
            min-height: 200px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 12px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px;
            line-height: 1.5;
            resize: vertical;
            outline: none;
            transition: border-color 0.3s ease;
        }

        .note-textarea:focus {
            border-color: #4299e1;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.1);
        }

        .note-modal-footer {
            padding: 15px 20px;
            border-top: 1px solid #e2e8f0;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .note-modal-footer button {
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
            border: 1px solid #e2e8f0;
        }

        .note-save-btn {
            background: #4299e1;
            color: white;
            border-color: #4299e1;
        }

        .note-save-btn:hover {
            background: #3182ce;
            border-color: #3182ce;
        }

        .note-cancel-btn {
            background: white;
            color: #4a5568;
        }

        .note-cancel-btn:hover {
            background: #f7fafc;
        }

        .note-delete-btn {
            background: #e53e3e;
            color: white;
            border-color: #e53e3e;
        }

        .note-delete-btn:hover {
            background: #c53030;
            border-color: #c53030;
        }        /* Hover controls for node creation */
        .hover-control {
            position: absolute;
            width: 24px;
            height: 24px;
            background: rgba(66, 153, 225, 0.1);
            border: 1px solid rgba(66, 153, 225, 0.3);
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            color: #4299e1;
            z-index: 30;
            transition: all 0.2s ease;
        }

        .hover-control:hover {
            background: rgba(66, 153, 225, 0.2);
            border-color: rgba(66, 153, 225, 0.6);
            transform: scale(1.1);
        }

        .hover-control.right {
            right: -42px; /* Increased from -36px to -42px for more clearance */
            top: 50%;
            transform: translateY(-50%);
        }

        .hover-control.right:hover {
            transform: translateY(-50%) scale(1.1);
        }

        .hover-control.down {
            bottom: -42px; /* Increased from -36px to -42px for more clearance */
            left: 50%;
            transform: translateX(-50%);
        }

        .hover-control.down:hover {
            transform: translateX(-50%) scale(1.1);
        }

        .hover-control.up {
            top: -42px; /* Increased from -36px to -42px for more clearance */
            left: 50%;
            transform: translateX(-50%);
        }

        .hover-control.up:hover {
            transform: translateX(-50%) scale(1.1);
        }

        /* Create bridge areas between node and controls to prevent hover loss */
        .hover-control.right::before {
            content: '';
            position: absolute;
            width: 18px; /* Increased to match new position */
            height: 24px;
            left: -18px; /* Adjusted for new position */
            top: 0;
            background: transparent;
        }

        .hover-control.up::before {
            content: '';
            position: absolute;
            width: 24px;
            height: 18px; /* Increased to match new position */
            left: 0;
            bottom: -18px; /* Adjusted for new position */
            background: transparent;
        }

        .hover-control.down::before {
            content: '';
            position: absolute;
            width: 24px;
            height: 18px; /* Increased to match new position */
            left: 0;
            top: -18px; /* Adjusted for new position */
            background: transparent;
        }

        /* Show controls on node hover or when hovering controls themselves */
        .node:hover .hover-control,
        .hover-control:hover {
            display: flex !important;
        }

        #save-notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(40, 40, 40, 0.85);
            color: #f0f0f0;
            padding: 12px 24px;
            border-radius: 8px;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease-out, visibility 0s linear 0.5s;
            font-family: sans-serif;
            font-size: 14px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        #save-notification.show {
            opacity: 1;
            visibility: visible;
            transition: opacity 0.5s ease-out, visibility 0s linear 0s;
        }

        /* File reload modal styles */
        .file-item {
            display: flex;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .file-item:hover {
            background: #e9ecef;
            border-color: #4299e1;
        }

        .file-item .file-icon {
            margin-right: 10px;
            font-size: 16px;
        }

        .file-item .file-name {
            flex: 1;
            font-weight: 500;
            color: #2d3748;
        }

        .file-item .file-action {
            font-size: 12px;
            color: #718096;
        }

        /* Status picker styles */
        .status-picker {
            position: fixed;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 200;
            display: none;
            flex-direction: column;
            width: 200px;
            padding: 8px;
        }

        .status-picker-options {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 8px;
        }

        .status-picker-description {
            padding: 6px 8px;
            font-size: 12px;
            color: #64748b;
            background: #f8fafc;
            border-radius: 4px;
            text-align: center;
            min-height: 16px;
            border-top: 1px solid #e2e8f0;
        }

        .status-option {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: all 0.2s ease;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .status-option:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .status-option.focused {
            transform: scale(1.1);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            border: 2px solid #4299e1;
        }

        .status-option.clear {
            background: #f7fafc;
            color: #718096;
            font-size: 16px;
            font-weight: bold;
        }

        /* Status placeholder button - shows when no status is assigned */
        .status-placeholder {
            position: absolute;
            top: -12px;
            left: -12px;
            width: 22px;
            height: 22px;
            background: rgba(255, 255, 255, 1);
            border: 1px solid #e2e8f0;
            border-radius: 50%;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #cbd5e0;
            z-index: 25;
            transition: all 0.3s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        }

        .status-placeholder:hover {
            transform: scale(1.1);
            background: rgba(255, 255, 255, 1);
            border-color: #4299e1;
            color: #4299e1;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12);
        }

        /* When both note and status icons are present, position them side by side */
        .node .note-indicator + .status-placeholder,
        .node .note-indicator + .status-icon {
            left: 12px;
        }

        /* Show status placeholder on node hover only when no status is assigned */
        .node:hover .status-placeholder {
            display: flex !important;
        }

        /* Status colors */
        .status-idea { background-color: #FFF7AE; }
        .status-planned { background-color: #FCECC2; }
        .status-not-started { background-color: #ECECEC; }
        .status-in-progress { background-color: #B8E4F8; }
        .status-waiting { background-color: #FFE1C6; }
        .status-blocked { background-color: #FFCACA; }
        .status-at-risk { background-color: #FFD6C8; }
        .status-in-review { background-color: #DAD5F2; }
        .status-completed { background-color: #CFF5D1; }
        .status-archived { background-color: #D7D7D7; }

        /* Status icon indicator */
        .status-icon {
            position: absolute;
            top: -12px;
            left: -12px;
            width: 22px;
            height: 22px;
            background: rgba(255, 255, 255, 1);
            border: 1px solid #e2e8f0;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            color: #718096;
            z-index: 25;
            transition: all 0.3s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        }

        .status-icon:hover {
            transform: scale(1.1);
            background: rgba(255, 255, 255, 1);
            border-color: #cbd5e0;
            color: #4a5568;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12);
        }

        /* When both note and status icons are present, position them side by side */
        .node .note-indicator + .status-icon {
            left: 12px; /* Position status icon next to note icon */
        }
    </style>
</head>

<body>    <div class="toolbar">
        <div class="file-status no-file" id="file-status">
            <span class="file-icon">📄</span>
            <span class="file-name" id="file-name">Untitled</span>
            <span class="unsaved-indicator" id="unsaved-indicator" style="display: none;">*</span>
        </div>
        <button onclick="saveMindMapAsMarkdown()">📝 Save Markdown</button>
        <button onclick="saveMindMapAsNewFile()">💾 Save As...</button> <!-- Added Save As button -->
        <button onclick="loadMindMapFromMarkdown()">📄 Load Markdown</button>
        <button onclick="toggleAutosave()" id="autosave-toggle">🔄 Autosave: ON</button>
        <button onclick="clearRecentFiles()" title="Clear recent files list" style="display: none;">🧹 Clear Recent</button>
    </div>

    <div id="canvas-container">
        <div id="mindmap-inner">
            <svg id="canvas" width="100%" height="100%">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#4299e1" opacity="0.8" />
                    </marker>
                </defs>
            </svg>
        </div>
    </div>

    <div class="instructions collapsed" id="instructions">
        <div class="instructions-header" onclick="toggleInstructions()">
            <div>
                <strong>Controls</strong>
                <span class="instructions-hint">(click to expand)</span>
            </div>
            <span class="instructions-toggle">▼</span>
        </div>        <div class="instructions-content">
            <div>Click/Enter: Create first item</div>
            <div>Enter: Edit selected item</div>
            <div>Space: Toggle checkbox completion</div>
            <div>N: Add/edit note for selected item</div>
            <div>S: Set status (use arrows to navigate, Enter to select)</div>
            <div>Delete: Delete item</div>
            <div>Ctrl+→: Add child or Expand</div>
            <div>Ctrl+↓: Add sibling below</div>
            <div>Ctrl+↑: Add sibling above</div>
            <div>Ctrl+←: Progressive collapse</div>
            <div>Arrow keys: Navigate</div>
            <div>Mouse wheel: Zoom</div>
            <div>Click & drag canvas: Pan</div>
            <div><strong>Auto-reload:</strong> Shows recent files on refresh</div>
        </div>
    </div>

    <div id="overlay" class="overlay hidden"></div>
    <div id="delete-confirm" class="delete-confirm hidden">
        <h3>Delete Item?</h3>
        <p>Are you sure you want to delete this item?</p>
        <div class="delete-confirm-buttons">
            <button class="cancel-btn" onclick="cancelDelete()">Cancel</button>
            <button class="confirm-btn" onclick="confirmDelete()">Delete</button>
        </div>
    </div>

    <!-- Note delete confirmation dialog -->
    <div id="delete-note-confirm" class="delete-confirm delete-note-confirm hidden">
        <h3>Delete Note?</h3>
        <p>Are you sure you want to delete this note? This action cannot be undone.</p>
        <div class="delete-confirm-buttons">
            <button class="cancel-btn" onclick="cancelDeleteNote()">Cancel</button>
            <button class="confirm-btn" onclick="confirmDeleteNote()">Delete Note</button>
        </div>
    </div>

    <!-- Note modal -->
    <div id="note-modal" class="note-modal hidden">
        <div class="note-modal-header">
            <h3>Item Note</h3>
            <button class="note-modal-close" onclick="closeNoteModal()">×</button>
        </div>
        <div class="note-modal-body">
            <textarea id="note-textarea" class="note-textarea" placeholder="Add your note here..."></textarea>
            <div style="font-size: 0.8em; color: #666; margin-top: 8px; text-align: center;">
                <strong>Alt+T</strong>: Insert timestamp • <strong>Ctrl+Enter</strong>: Save • <strong>Esc</strong>: Cancel
            </div>
        </div>
        <div class="note-modal-footer">
            <button class="note-delete-btn" onclick="deleteNote()" id="note-delete-btn" style="display: none;">Delete
                Note</button>
            <button class="note-cancel-btn" onclick="closeNoteModal()">Cancel</button>
            <button class="note-save-btn" onclick="saveNote()">Save Note</button>
        </div>
    </div>

    <!-- File selection modal for auto-reload -->
    <div id="file-reload-modal" class="note-modal hidden">
        <div class="note-modal-header">
            <h3>Select File to Reload</h3>
            <button class="note-modal-close" onclick="closeFileReloadModal()">×</button>
        </div>
        <div class="note-modal-body">
            <p><strong>Recent files found:</strong></p>
            <p style="font-size: 0.9em; color: #666; margin-bottom: 15px;">Click a file below to open the file picker. You'll need to manually navigate to and select the file (browsers don't allow auto-selection for security).</p>
            <div id="recent-files-list" style="margin-top: 15px;">
                <!-- File list will be populated here -->
            </div>
        </div>
        <div class="note-modal-footer">
            <button class="note-cancel-btn" onclick="closeFileReloadModal()">Start Fresh</button>
        </div>
    </div>

    <!-- Published: 2025-08-28 12:15:04 UTC -->
    <script>
        const PUBLISHED_TIMESTAMP = '2025-08-28 12:15:04 UTC';
        // --- State ---
        let nodes = [];
        let selectedNode = null;
        let nextId = 1;
        let pan = { x: 0, y: 0 };
        let zoom = 1;
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        let dragStart = { x: 0, y: 0 };
        let editingNode = null;
        let renderScheduled = false;
        let nodeToDelete = null;
        let currentNoteNode = null; // For note editing

        const canvasContainer = document.getElementById('canvas-container');
        const mindmapInner = document.getElementById('mindmap-inner');
        const canvas = document.getElementById('canvas');

        // Status configuration
        const statusConfig = {
            'idea': { icon: '💡', color: '#FFF7AE', name: 'Idea / Someday' },
            'planned': { icon: '📋', color: '#FCECC2', name: 'Planned / Ready' },
            'not-started': { icon: '⏸', color: '#ECECEC', name: 'Not Started' },
            'in-progress': { icon: '⚙️', color: '#B8E4F8', name: 'In Progress' },
            'waiting': { icon: '⏳', color: '#FFE1C6', name: 'Waiting / On-Hold' },
            'blocked': { icon: '⛔', color: '#FFCACA', name: 'Blocked' },
            'at-risk': { icon: '⚠️', color: '#FFD6C8', name: 'At Risk' },
            'in-review': { icon: '🔍', color: '#DAD5F2', name: 'In Review / QA' },
            'completed': { icon: '✅', color: '#CFF5D1', name: 'Completed' },
            'archived': { icon: '🗂', color: '#D7D7D7', name: 'Archived / Dropped' }
        };

        // --- Status Management ---
        function generateTimestamp() {
            const now = new Date();
            return now.getFullYear() + '-' +
                String(now.getMonth() + 1).padStart(2, '0') + '-' +
                String(now.getDate()).padStart(2, '0') + ' ' +
                String(now.getHours()).padStart(2, '0') + ':' +
                String(now.getMinutes()).padStart(2, '0') + ':' +
                String(now.getSeconds()).padStart(2, '0') + ': ';
        }

        function addStatusChangeNote(node, fromStatus, toStatus) {
            const timestamp = generateTimestamp();
            const fromName = fromStatus ? statusConfig[fromStatus]?.name || fromStatus : 'None';
            const toName = toStatus ? statusConfig[toStatus]?.name || toStatus : 'None';
            const statusChangeNote = `Status changed from "${fromName}" to "${toName}"\n`;
            
            // Add to existing note or create new note
            if (node.note && node.note.trim()) {
                node.note += '\n' + timestamp + statusChangeNote;
            } else {
                node.note = timestamp + statusChangeNote;
            }
        }

        function setNodeStatus(node, statusKey) {
            const oldStatus = node.status;
            node.status = statusKey;
            node.statusIcon = statusKey ? statusConfig[statusKey].icon : '';
            
            // Add automatic status change note
            addStatusChangeNote(node, oldStatus, statusKey);
            
            // Auto-sync with checkbox: if assigning non-completed status to completed item, uncheck it
            if (node.completed && statusKey !== 'completed') {
                node.completed = false;
                // Update checkbox visual state if element exists
                if (node.element) {
                    const checkbox = node.element.querySelector('.node-checkbox');
                    if (checkbox) {
                        checkbox.classList.remove('checked');
                    }
                    node.element.classList.remove('completed');
                }
            }
            // Auto-sync with checkbox: if assigning completed status, check the box
            else if (!node.completed && statusKey === 'completed') {
                node.completed = true;
                // Update checkbox visual state if element exists
                if (node.element) {
                    const checkbox = node.element.querySelector('.node-checkbox');
                    if (checkbox) {
                        checkbox.classList.add('checked');
                    }
                    node.element.classList.add('completed');
                }
            }
            
            markAsChanged();
            
            // Update the node element if it exists
            if (node.element) {
                updateNodeStatusElements(node);
            }
        }

        function clearNodeStatus(node) {
            const oldStatus = node.status;
            node.status = '';
            node.statusIcon = '';
            
            // Add automatic status change note
            addStatusChangeNote(node, oldStatus, '');
            
            // If clearing completed status, also uncheck the checkbox
            if (node.completed) {
                node.completed = false;
                // Update checkbox visual state if element exists
                if (node.element) {
                    const checkbox = node.element.querySelector('.node-checkbox');
                    if (checkbox) {
                        checkbox.classList.remove('checked');
                    }
                    node.element.classList.remove('completed');
                }
            }
            
            markAsChanged();
            
            // Update the node element if it exists
            if (node.element) {
                updateNodeStatusElements(node);
            }
        }

        function updateNodeStatusElements(node) {
            // Remove any existing status classes
            Object.keys(statusConfig).forEach(status => {
                node.element.classList.remove(`status-${status}`);
            });
            
            // Apply new status
            if (node.status && statusConfig[node.status]) {
                node.element.classList.add(`status-${node.status}`);
            }
            
            // Remove existing status elements
            const existingStatusIcon = node.element.querySelector('.status-icon');
            const existingStatusPlaceholder = node.element.querySelector('.status-placeholder');
            if (existingStatusIcon) existingStatusIcon.remove();
            if (existingStatusPlaceholder) existingStatusPlaceholder.remove();
            
            // Also remove any existing note indicator to re-add it in the correct position
            const existingNoteIndicator = node.element.querySelector('.note-indicator');
            if (existingNoteIndicator) existingNoteIndicator.remove();
            
            // Add note indicator first (if note exists)
            if (node.note && node.note.trim()) {
                const noteIndicator = document.createElement('div');
                noteIndicator.className = 'note-indicator has-note';
                noteIndicator.innerHTML = '📝';
                // Show note text in tooltip, truncate if too long
                const notePreview = node.note.length > 100 ? node.note.substring(0, 100) + '...' : node.note;
                noteIndicator.title = `Note: ${notePreview}\n\nClick to edit`;
                noteIndicator.onclick = e => {
                    e.stopPropagation();
                    openNoteModal(node);
                };
                node.element.appendChild(noteIndicator);
            }
            
            // Add appropriate status element after note indicator
            if (node.status && statusConfig[node.status]) {
                // Add status icon
                const statusIcon = createStatusIcon(node);
                node.element.appendChild(statusIcon);
            } else {
                // Add status placeholder
                const statusPlaceholder = createStatusPlaceholder(node);
                node.element.appendChild(statusPlaceholder);
            }
        }

        function createStatusIcon(node) {
            const statusIcon = document.createElement('div');
            statusIcon.className = 'status-icon';
            statusIcon.innerHTML = statusConfig[node.status].icon;
            statusIcon.title = statusConfig[node.status].name + ' (click to change)';
            statusIcon.onclick = e => {
                e.stopPropagation();
                showStatusPicker(e, node);
            };
            return statusIcon;
        }

        function createStatusPlaceholder(node) {
            const placeholder = document.createElement('div');
            placeholder.className = 'status-placeholder';
            placeholder.innerHTML = '+';
            placeholder.title = 'Set status';
            placeholder.onclick = e => {
                e.stopPropagation();
                showStatusPicker(e, node);
            };
            return placeholder;
        }

        function showStatusPicker(event, node) {
            // Hide any existing status picker
            hideStatusPicker();
            
            // Create and show new status picker
            const picker = createStatusPicker(node);
            document.body.appendChild(picker);
            
            // Position the picker near the click location but avoid overlapping with controls
            const rect = event.target.getBoundingClientRect();
            const pickerWidth = 200;
            const pickerHeight = 140; // Approximate height (increased for description area)
            
            // Try to position to the right of the node first
            let left = rect.right + 10;
            let top = rect.top - 20;
            
            // If picker would go off screen to the right, position to the left
            if (left + pickerWidth > window.innerWidth) {
                left = rect.left - pickerWidth - 10;
            }
            
            // If picker would go off screen at the top, position below
            if (top < 0) {
                top = rect.bottom + 10;
            }
            
            // If picker would go off screen at the bottom, position above
            if (top + pickerHeight > window.innerHeight) {
                top = rect.top - pickerHeight - 10;
            }
            
            picker.style.left = left + 'px';
            picker.style.top = top + 'px';
            picker.style.display = 'flex';
        }

        function createStatusPicker(node) {
            const picker = document.createElement('div');
            picker.className = 'status-picker';
            
            // Create options container
            const optionsContainer = document.createElement('div');
            optionsContainer.className = 'status-picker-options';
            
            // Create description area
            const descriptionArea = document.createElement('div');
            descriptionArea.className = 'status-picker-description';
            descriptionArea.textContent = 'Select a status';
            
            // Add clear option if node has status
            if (node.status) {
                const clearOption = document.createElement('div');
                clearOption.className = 'status-option clear';
                clearOption.innerHTML = '×';
                clearOption.title = 'Clear status';
                clearOption.onclick = e => {
                    e.stopPropagation();
                    clearNodeStatus(node);
                    hideStatusPicker();
                };
                clearOption.onmouseenter = () => {
                    descriptionArea.textContent = 'Clear status';
                };
                clearOption.onmouseleave = () => {
                    descriptionArea.textContent = 'Select a status';
                };
                optionsContainer.appendChild(clearOption);
            }
            
            // Add status options
            Object.entries(statusConfig).forEach(([key, config]) => {
                const option = document.createElement('div');
                option.className = `status-option status-${key}`;
                option.innerHTML = config.icon;
                option.title = config.name;
                option.onclick = e => {
                    e.stopPropagation();
                    setNodeStatus(node, key);
                    hideStatusPicker();
                };
                option.onmouseenter = () => {
                    descriptionArea.textContent = config.name;
                };
                option.onmouseleave = () => {
                    descriptionArea.textContent = 'Select a status';
                };
                optionsContainer.appendChild(option);
            });
            
            picker.appendChild(optionsContainer);
            picker.appendChild(descriptionArea);
            
            return picker;
        }

        function hideStatusPicker() {
            document.querySelectorAll('.status-picker').forEach(picker => {
                picker.remove();
            });
            // Remove keyboard event listener
            document.removeEventListener('keydown', handleStatusPickerKeyboard);
        }

        // Keyboard-navigable status picker
        let currentKeyboardStatusNode = null;
        let statusPickerOptions = [];
        let focusedOptionIndex = 0;

        function showKeyboardStatusPicker(node) {
            // Hide any existing status picker
            hideStatusPicker();
            
            currentKeyboardStatusNode = node;
            
            // Create and show new status picker
            const picker = createKeyboardStatusPicker(node);
            document.body.appendChild(picker);
            
            // Position the picker near the selected item
            if (node.element) {
                const rect = node.element.getBoundingClientRect();
                const pickerWidth = 200;
                const pickerHeight = 140;
                
                // Position to the right of the node
                let left = rect.right + 10;
                let top = rect.top - 20;
                
                // If picker would go off screen to the right, position to the left
                if (left + pickerWidth > window.innerWidth) {
                    left = rect.left - pickerWidth - 10;
                }
                
                // If picker would go off screen at the top, position below
                if (top < 0) {
                    top = rect.bottom + 10;
                }
                
                // If picker would go off screen at the bottom, position above
                if (top + pickerHeight > window.innerHeight) {
                    top = rect.top - pickerHeight - 10;
                }
                
                picker.style.left = left + 'px';
                picker.style.top = top + 'px';
            } else {
                // Center on screen if item element not available
                picker.style.left = '50%';
                picker.style.top = '50%';
                picker.style.transform = 'translate(-50%, -50%)';
            }
            
            picker.style.display = 'flex';
            
            // Focus first option
            focusedOptionIndex = 0;
            updateStatusPickerFocus();
            
            // Add keyboard event listener
            document.addEventListener('keydown', handleStatusPickerKeyboard);
        }

        function createKeyboardStatusPicker(node) {
            const picker = document.createElement('div');
            picker.className = 'status-picker';
            picker.id = 'keyboard-status-picker';
            
            // Create options container
            const optionsContainer = document.createElement('div');
            optionsContainer.className = 'status-picker-options';
            
            // Create description area
            const descriptionArea = document.createElement('div');
            descriptionArea.className = 'status-picker-description';
            descriptionArea.id = 'keyboard-status-description';
            descriptionArea.textContent = 'Use arrow keys to navigate, Enter to select';
            
            statusPickerOptions = [];
            
            // Add clear option if node has status
            if (node.status) {
                const clearOption = document.createElement('div');
                clearOption.className = 'status-option clear';
                clearOption.innerHTML = '×';
                clearOption.title = 'Clear status';
                clearOption.dataset.action = 'clear';
                clearOption.dataset.description = 'Clear status';
                optionsContainer.appendChild(clearOption);
                statusPickerOptions.push(clearOption);
            }
            
            // Add status options
            Object.entries(statusConfig).forEach(([key, config]) => {
                const option = document.createElement('div');
                option.className = `status-option status-${key}`;
                option.innerHTML = config.icon;
                option.title = config.name;
                option.dataset.statusKey = key;
                option.dataset.description = config.name;
                optionsContainer.appendChild(option);
                statusPickerOptions.push(option);
            });
            
            picker.appendChild(optionsContainer);
            picker.appendChild(descriptionArea);
            
            return picker;
        }

        function updateStatusPickerFocus() {
            // Remove focus from all options
            statusPickerOptions.forEach(option => {
                option.classList.remove('focused');
            });
            
            // Add focus to current option and update description
            if (statusPickerOptions[focusedOptionIndex]) {
                statusPickerOptions[focusedOptionIndex].classList.add('focused');
                
                // Update description area with focused option's description
                const descriptionArea = document.getElementById('keyboard-status-description');
                if (descriptionArea) {
                    const focusedOption = statusPickerOptions[focusedOptionIndex];
                    const description = focusedOption.dataset.description || 'Use arrow keys to navigate, Enter to select';
                    descriptionArea.textContent = description;
                }
            }
        }

        function handleStatusPickerKeyboard(e) {
            // Only handle if keyboard status picker is open
            if (!document.getElementById('keyboard-status-picker')) {
                return;
            }
            
            e.preventDefault();
            e.stopPropagation();
            
            switch (e.key) {
                case 'Escape':
                    hideStatusPicker();
                    break;
                    
                case 'Enter':
                    // Select current focused option
                    const selectedOption = statusPickerOptions[focusedOptionIndex];
                    if (selectedOption) {
                        if (selectedOption.dataset.action === 'clear') {
                            clearNodeStatus(currentKeyboardStatusNode);
                        } else if (selectedOption.dataset.statusKey) {
                            setNodeStatus(currentKeyboardStatusNode, selectedOption.dataset.statusKey);
                        }
                    }
                    hideStatusPicker();
                    break;
                    
                case 'ArrowRight':
                    // Move right within the same row
                    focusedOptionIndex = (focusedOptionIndex + 1) % statusPickerOptions.length;
                    updateStatusPickerFocus();
                    break;
                    
                case 'ArrowLeft':
                    // Move left within the same row
                    focusedOptionIndex = (focusedOptionIndex - 1 + statusPickerOptions.length) % statusPickerOptions.length;
                    updateStatusPickerFocus();
                    break;
                    
                case 'ArrowDown':
                    // Move down to next row (2D grid navigation)
                    const itemsPerRow = calculateItemsPerRow();
                    const newDownIndex = focusedOptionIndex + itemsPerRow;
                    if (newDownIndex < statusPickerOptions.length) {
                        focusedOptionIndex = newDownIndex;
                    } else {
                        // Wrap to first row, same column
                        const currentColumn = focusedOptionIndex % itemsPerRow;
                        focusedOptionIndex = currentColumn;
                    }
                    updateStatusPickerFocus();
                    break;
                    
                case 'ArrowUp':
                    // Move up to previous row (2D grid navigation)
                    const itemsPerRowUp = calculateItemsPerRow();
                    const newUpIndex = focusedOptionIndex - itemsPerRowUp;
                    if (newUpIndex >= 0) {
                        focusedOptionIndex = newUpIndex;
                    } else {
                        // Wrap to last row, same column
                        const currentColumn = focusedOptionIndex % itemsPerRowUp;
                        const totalRows = Math.ceil(statusPickerOptions.length / itemsPerRowUp);
                        const lastRowStartIndex = (totalRows - 1) * itemsPerRowUp;
                        const targetIndex = lastRowStartIndex + currentColumn;
                        // Make sure we don't go beyond the total number of options
                        focusedOptionIndex = Math.min(targetIndex, statusPickerOptions.length - 1);
                    }
                    updateStatusPickerFocus();
                    break;
            }
        }

        function calculateItemsPerRow() {
            // Based on status picker width (200px) and item width (28px + gap)
            // Each item is 28px wide + 4px gap = 32px total
            // With 8px padding on each side: available width = 200 - 16 = 184px
            // Items per row = floor(184 / 32) = 5 items per row
            return 5;
        }

        // Hide status picker when clicking elsewhere
        document.addEventListener('click', hideStatusPicker);

        // --- Pan/Zoom ---
        function applyTransform() {
            mindmapInner.style.transform = `translate(${pan.x}px,${pan.y}px) scale(${zoom})`;
        }
        applyTransform();

        // Check for auto-reload on page load - DISABLED
        // document.addEventListener('DOMContentLoaded', checkForAutoReload);
        // Also check if DOM is already loaded
        // if (document.readyState !== 'loading') {
        //     checkForAutoReload();
        // }

        canvasContainer.addEventListener('mousedown', e => {
            if (e.button !== 0) return;
            // Check if clicking on empty space
            if (e.target === canvasContainer || e.target === mindmapInner || e.target === canvas) {
                if (nodes.length === 0) {
                    createFirstNode(e);
                    return;
                }
                isPanning = true;
                panStart = { x: e.clientX, y: e.clientY };
                dragStart = { x: pan.x, y: pan.y };
                canvasContainer.style.cursor = 'grabbing';
            }
        });

        window.addEventListener('mousemove', e => {
            if (isPanning) {
                pan.x = dragStart.x + (e.clientX - panStart.x);
                pan.y = dragStart.y + (e.clientY - panStart.y);
                applyTransform();
            }
        });

        window.addEventListener('mouseup', e => {
            isPanning = false;
            canvasContainer.style.cursor = 'grab';
        });

        canvasContainer.addEventListener('wheel', e => {
            e.preventDefault();
            const scale = Math.exp(-e.deltaY * 0.001);
            const rect = mindmapInner.getBoundingClientRect();
            const cx = (e.clientX - rect.left) / zoom;
            const cy = (e.clientY - rect.top) / zoom;
            zoom *= scale;
            zoom = Math.max(0.2, Math.min(zoom, 2.5));
            pan.x -= (cx * (scale - 1)) * zoom;
            pan.y -= (cy * (scale - 1)) * zoom;
            applyTransform();
        }, { passive: false });        // --- Item creation ---
        function createFirstNode(e) {
            // Position the first item on the left side with nice margin (200px from left edge)
            const leftMargin = 200;
            const x = (leftMargin - pan.x) / zoom;
            const y = (window.innerHeight / 2 - pan.y) / zoom;
            const node = createNode('New Item', x, y, null);
            scheduleRender();
            // Wait for render to complete before selecting and editing
            setTimeout(() => {
                selectNode(node);
                startEditing(node);
            }, 50);
        }
        
        function createNode(text, x, y, parent) {
            const node = {
                id: nextId++,
                text,
                x, y,
                parent,
                children: [],
                collapsed: false,
                element: null,
                expandBtn: null,
                note: '', // Add note property
                completed: false, // Add completed property for checkbox functionality
                status: '', // Add status property for status tracking
                statusIcon: '' // Add status icon property
            };
            if (parent) parent.children.push(node);
            nodes.push(node);
            
            // Mark as changed when creating new nodes (except during initial load)
            if (nodes.length > 1 || text !== 'New Item') {
                markAsChanged();
            }
            
            return node;
        }

        // --- Performance optimized rendering ---
        function scheduleRender() {
            if (!renderScheduled) {
                renderScheduled = true;
                requestAnimationFrame(() => {
                    render();
                    renderScheduled = false;
                });
            }
        }

        // Lightweight update for position changes only (no flickering)
        function updatePositionsAndEdges() {
            // Update node positions without recreating elements
            nodes.forEach(node => {
                if (node.element) {
                    node.element.style.left = node.x + 'px';
                    node.element.style.top = node.y + 'px';

                    // Update visibility based on collapsed state
                    if (isNodeHidden(node)) {
                        node.element.style.display = 'none';
                    } else {
                        node.element.style.display = 'flex';
                    }
                }
            });

            // Smoothly update edges without clearing everything
            updateEdges();
        }

        function updateEdges() {
            // Remove existing edges but keep defs
            const edges = canvas.querySelectorAll('.edge');
            edges.forEach(edge => edge.remove());

            // Redraw edges
            nodes.forEach(node => {
                if (node.parent && !isNodeHidden(node)) {
                    drawEdge(node.parent, node);
                }
            });
        }

        function render() {
            // Remove all node elements
            mindmapInner.querySelectorAll('.node').forEach(el => el.remove());
            // Clear canvas edges
            while (canvas.firstChild) {
                canvas.removeChild(canvas.firstChild);
            }
            // Re-add defs
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            marker.setAttribute('id', 'arrowhead');
            marker.setAttribute('markerWidth', '10');
            marker.setAttribute('markerHeight', '7');
            marker.setAttribute('refX', '9');
            marker.setAttribute('refY', '3.5');
            marker.setAttribute('orient', 'auto');
            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
            polygon.setAttribute('fill', '#4299e1');
            polygon.setAttribute('opacity', '0.8');
            marker.appendChild(polygon);
            defs.appendChild(marker);
            canvas.appendChild(defs);

            // Render nodes recursively
            nodes.forEach(node => {
                if (!node.parent) renderSubtree(node);
            });

            // Render edges after all nodes are rendered
            setTimeout(() => {
                nodes.forEach(node => {
                    if (node.parent && !isNodeHidden(node)) {
                        drawEdge(node.parent, node);
                    }
                });
            }, 0);
        }

        function isNodeHidden(node) {
            if (!node.parent) return false;
            if (node.parent.collapsed) return true;
            return isNodeHidden(node.parent);
        }
        
        function renderSubtree(node) {
            // Node element
            const nodeEl = document.createElement('div');
            nodeEl.className = 'node';
            if (node.completed) nodeEl.classList.add('completed');
            
            // Apply status styling if set
            if (node.status && statusConfig[node.status]) {
                nodeEl.classList.add(`status-${node.status}`);
            }
            
            nodeEl.style.left = node.x + 'px';
            nodeEl.style.top = node.y + 'px';

            // Add checkbox
            const checkbox = document.createElement('div');
            checkbox.className = 'node-checkbox';
            if (node.completed) checkbox.classList.add('checked');
            checkbox.onclick = e => {
                e.stopPropagation();
                toggleNodeCompletion(node);
            };
            nodeEl.appendChild(checkbox);

            // Create content wrapper for text (to apply strikethrough when completed)
            const contentWrapper = document.createElement('span');
            contentWrapper.className = 'node-content';
            
            // Better text handling
            const textContent = node.text || 'New Item';
            contentWrapper.textContent = textContent;
            nodeEl.appendChild(contentWrapper);

            // Adjust width based on text length (account for checkbox width)
            const textLength = textContent.length;
            if (textLength > 12) {
                nodeEl.style.width = Math.min(200, Math.max(140, textLength * 8 + 32)) + 'px';
            } else {
                nodeEl.style.width = '140px';
            }

            if (selectedNode === node) nodeEl.classList.add('selected');
            if (editingNode === node) nodeEl.classList.add('editing');

            nodeEl.onclick = e => {
                e.stopPropagation();
                selectNode(node);
            };

            // Add double-click to edit functionality
            nodeEl.ondblclick = e => {
                e.stopPropagation();
                e.preventDefault();
                selectNode(node);
                startEditing(node);
            };

            // Add right-click context menu
            nodeEl.oncontextmenu = e => {
                e.preventDefault();
                e.stopPropagation();
                showContextMenu(e, node);
            };
            
            // Expand/collapse button
            if (node.children.length > 0) {
                const btn = document.createElement('button');
                btn.className = 'expand-btn';
                btn.textContent = node.collapsed ? '+' : '−';
                btn.onclick = e => {
                    e.stopPropagation();
                    toggleCollapse(node);
                };
                nodeEl.appendChild(btn);
                node.expandBtn = btn;
            }

            // Note indicator - only show when note exists
            if (node.note && node.note.trim()) {
                const noteIndicator = document.createElement('div');
                noteIndicator.className = 'note-indicator has-note';
                noteIndicator.innerHTML = '📝';
                // Show note text in tooltip, truncate if too long
                const notePreview = node.note.length > 100 ? node.note.substring(0, 100) + '...' : node.note;
                noteIndicator.title = `Note: ${notePreview}\n\nClick to edit`;
                noteIndicator.onclick = e => {
                    e.stopPropagation();
                    openNoteModal(node);
                };
                nodeEl.appendChild(noteIndicator);
            }

            // Status icon or placeholder
            if (node.status && statusConfig[node.status]) {
                // Add status icon
                const statusIcon = createStatusIcon(node);
                nodeEl.appendChild(statusIcon);
            } else {
                // Add status placeholder
                const statusPlaceholder = createStatusPlaceholder(node);
                nodeEl.appendChild(statusPlaceholder);
            }

            // Add hover controls for item creation
            addHoverControls(nodeEl, node);

            node.element = nodeEl;
            mindmapInner.appendChild(nodeEl);

            if (!node.collapsed) {
                node.children.forEach(child => renderSubtree(child));
            }
        } 
        
        function addHoverControls(nodeEl, node) {
            const isRoot = !node.parent;
            const hasChildren = node.children.length > 0;

            // Remove all previous hover controls if any
            nodeEl.querySelectorAll('.hover-control').forEach(ctrl => ctrl.remove());

            if (hasChildren) {
                // Any node with children: only show up/down controls for non-root nodes
                if (!isRoot) {
                    const upControl = document.createElement('div');
                    upControl.className = 'hover-control up';
                    upControl.innerHTML = '+';
                    upControl.title = 'Add sibling above';
                    upControl.onclick = e => {
                        e.stopPropagation();
                        createSiblingNode(node, 0);
                    };
                    nodeEl.appendChild(upControl);

                    const downControl = document.createElement('div');
                    downControl.className = 'hover-control down';
                    downControl.innerHTML = '+';
                    downControl.title = 'Add sibling below';
                    downControl.onclick = e => {
                        e.stopPropagation();
                        createSiblingNode(node, 1);
                    };
                    nodeEl.appendChild(downControl);
                }
                // No right control for any node with children
                return;
            }

            // Node without children
            if (isRoot) {
                // Root item without children: show right control only
                const rightControl = document.createElement('div');
                rightControl.className = 'hover-control right';
                rightControl.innerHTML = '+';
                rightControl.title = 'Add child item';
                rightControl.onclick = e => {
                    e.stopPropagation();
                    createChildNode(node);
                };
                nodeEl.appendChild(rightControl);
            } else {
                // Non-root item without children: show all three controls
                const rightControl = document.createElement('div');
                rightControl.className = 'hover-control right';
                rightControl.innerHTML = '+';
                rightControl.title = 'Add child item';
                rightControl.onclick = e => {
                    e.stopPropagation();
                    createChildNode(node);
                };
                nodeEl.appendChild(rightControl);

                const upControl = document.createElement('div');
                upControl.className = 'hover-control up';
                upControl.innerHTML = '+';
                upControl.title = 'Add sibling above';
                upControl.onclick = e => {
                    e.stopPropagation();
                    createSiblingNode(node, 0);
                };
                nodeEl.appendChild(upControl);

                const downControl = document.createElement('div');
                downControl.className = 'hover-control down';
                downControl.innerHTML = '+';
                downControl.title = 'Add sibling below';
                downControl.onclick = e => {
                    e.stopPropagation();
                    createSiblingNode(node, 1);
                };
                nodeEl.appendChild(downControl);
            }
        }

        function drawEdge(parent, child) {
            if (!parent.element || !child.element) return;

            const parentRect = parent.element.getBoundingClientRect();
            const childRect = child.element.getBoundingClientRect();
            const containerRect = mindmapInner.getBoundingClientRect();

            // Calculate positions relative to the mindmap container
            const startX = (parentRect.right - containerRect.left) / zoom;
            const startY = (parentRect.top + parentRect.height / 2 - containerRect.top) / zoom;
            const endX = (childRect.left - containerRect.left) / zoom;
            const endY = (childRect.top + childRect.height / 2 - containerRect.top) / zoom;

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const midX = (startX + endX) / 2;
            path.setAttribute('d', `M${startX},${startY} C${midX},${startY} ${midX},${endY} ${endX},${endY}`);
            path.setAttribute('stroke', '#4299e1');
            path.setAttribute('stroke-width', '2');
            path.setAttribute('fill', 'none');
            path.setAttribute('opacity', '0.8');
            path.classList.add('edge');
            canvas.appendChild(path);
        }        // --- Auto arrange (left->right tree, always visible) ---
        function autoArrange(fullRender = false) {
            if (nodes.length === 0) return;
            // Find root(s)
            const roots = nodes.filter(n => !n.parent);

            // If we have existing roots, preserve their viewport position
            let preservedRootPosition = null;
            if (roots.length > 0 && roots[0].element) {
                const rootRect = roots[0].element.getBoundingClientRect();
                const containerRect = mindmapInner.getBoundingClientRect();
                preservedRootPosition = {
                    x: (rootRect.left - containerRect.left) / zoom,
                    y: (rootRect.top - containerRect.top) / zoom
                };
            }
            // Arrange multiple roots with proper spacing on the left side
            const leftMargin = 200; // Consistent left margin
            let currentY = 40; // Reduced margin from top
            roots.forEach(root => {
                const subtreeHeight = measureSubtreeHeight(root);
                if (preservedRootPosition && root === roots[0]) {
                    // Keep first root at its current position
                    arrangeSubtree(root, root.x, root.y, 0);
                } else {
                    // Position other roots with proper spacing, aligned to left margin
                    arrangeSubtree(root, leftMargin, currentY + subtreeHeight / 2, 0);
                }
                currentY += subtreeHeight + 50; // Reduced spacing between root trees
            });
            // Don't center the mindmap - let it grow from left to right
            // Only center vertically if this is initial load and no preserved position
            if (!preservedRootPosition && nodes.length > 0) {
                centerMindmapVertically();
            }

            // Use appropriate update method based on whether we need full render
            if (fullRender) {
                scheduleRender();
            } else {
                updatePositionsAndEdges();
            }
        }function measureSubtreeHeight(node) {
            if (node.collapsed || node.children.length === 0) {
                // Base node height plus minimal space for hover controls
                return 80 + 50; // Base height + reduced hover control clearance
            }

            // Calculate the height needed for all visible children
            const childHeights = node.children.map(child => measureSubtreeHeight(child));
            const totalChildHeight = childHeights.reduce((sum, h) => sum + h, 0);
            
            // Reduced spacing calculation for more compact layout
            const baseSpacing = 30; // Reduced minimum spacing between children
            const scaledSpacing = Math.max(baseSpacing, 80 / Math.sqrt(node.children.length));
            const totalSpacing = Math.max(0, (node.children.length - 1) * scaledSpacing);

            // The subtree height is the larger of:
            // 1. The total height needed for all children plus spacing
            // 2. The minimum height for this node including hover control clearance
            const minNodeHeight = 80 + 50; // Reduced base height + hover control clearance
            const totalRequiredHeight = totalChildHeight + totalSpacing;
            
            return Math.max(minNodeHeight, totalRequiredHeight);
        }        function arrangeSubtree(node, x, y, level) {
            // Only update position if this is root node being initially placed
            // or if it's a child node (always update children positions)
            if (level > 0 || !node.element) {
                node.x = x;
                node.y = y;
            }

            if (node.collapsed || node.children.length === 0) return;

            // Calculate total height needed for all children
            const childHeights = node.children.map(child => measureSubtreeHeight(child));
            const totalHeight = childHeights.reduce((sum, h) => sum + h, 0);
            
            // Use the same reduced spacing calculation as measureSubtreeHeight
            const baseSpacing = 30;
            const scaledSpacing = Math.max(baseSpacing, 80 / Math.sqrt(node.children.length));

            // Start positioning children from the top of the allocated space
            let currentY = node.y - totalHeight / 2;

            node.children.forEach((child, index) => {
                const childHeight = childHeights[index];
                // Position child at the center of its allocated height
                const childCenterY = currentY + childHeight / 2;
                
                // Reduced horizontal spacing for more compact layout
                // Base spacing (280px) + hover control space (20px) = 300px
                arrangeSubtree(child, node.x + 300, childCenterY, level + 1);
                
                // Move to next child's position
                currentY += childHeight + scaledSpacing;
            });
        }        function centerMindmap() {
            // Compute bounding box of all visible nodes, accounting for hover controls
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            nodes.forEach(n => {
                if (isNodeVisible(n)) {
                    // Reduced hover control margin for more compact centering
                    const hoverMargin = 25; // Reduced hover control margin
                    minX = Math.min(minX, n.x - hoverMargin);
                    minY = Math.min(minY, n.y - hoverMargin);
                    maxX = Math.max(maxX, n.x + 200 + hoverMargin); // Max node width + hover margin
                    maxY = Math.max(maxY, n.y + 40 + hoverMargin); // Node height + hover margin
                }
            });
            if (minX === Infinity) return;
            const mapW = maxX - minX, mapH = maxY - minY;
            const cx = window.innerWidth / 2, cy = window.innerHeight / 2;
            pan.x = cx - (minX + mapW / 2) * zoom;
            pan.y = cy - (minY + mapH / 2) * zoom;
            applyTransform();
        }

        function centerMindmapVertically() {
            // Only center vertically, keep left alignment, account for hover controls
            let minY = Infinity, maxY = -Infinity;
            nodes.forEach(n => {
                if (isNodeVisible(n)) {
                    const hoverMargin = 25; // Reduced hover control margin
                    minY = Math.min(minY, n.y - hoverMargin);
                    maxY = Math.max(maxY, n.y + 40 + hoverMargin);
                }
            });
            if (minY === Infinity) return;
            const mapH = maxY - minY;
            const cy = window.innerHeight / 2;
            pan.y = cy - (minY + mapH / 2) * zoom;
            applyTransform();
        }

        function isNodeVisible(node) {
            if (!node.parent) return true;
            if (node.parent.collapsed) return false;
            return isNodeVisible(node.parent);
        }

        // --- Checkbox functionality ---        
        function toggleNodeCompletion(node) {
            node.completed = !node.completed;
            markAsChanged(); // Mark as changed when completion status changes
            
            // Auto-assign status based on checkbox state
            if (node.completed) {
                // When checking the box, automatically set status to "completed"
                setNodeStatus(node, 'completed');
            } else {
                // When unchecking, clear the completed status but keep other statuses
                if (node.status === 'completed') {
                    clearNodeStatus(node);
                }
            }
            
            // Update the visual state without full re-render
            if (node.element) {
                const checkbox = node.element.querySelector('.node-checkbox');
                const contentWrapper = node.element.querySelector('.node-content');
                
                if (node.completed) {
                    node.element.classList.add('completed');
                    checkbox.classList.add('checked');
                } else {
                    node.element.classList.remove('completed');
                    checkbox.classList.remove('checked');
                }
            }
        }

        // --- Node selection and editing ---
        function selectNode(node) {
            // Only update selection classes, don't re-render
            if (selectedNode && selectedNode.element) {
                selectedNode.element.classList.remove('selected');
            }
            selectedNode = node;
            if (selectedNode && selectedNode.element) {
                selectedNode.element.classList.add('selected');            }
        }
        
        function startEditing(node) {
            if (editingNode === node) return;
            editingNode = node;

            // Don't re-render, just update the node in place
            if (node.element) {
                node.element.classList.add('editing');
                const contentWrapper = node.element.querySelector('.node-content');
                const input = document.createElement('input');
                input.value = node.text;
                input.style.width = '100%';
                input.onkeydown = e => {
                    if (e.key === 'Enter') {
                        stopEditing(node, input.value);
                        e.preventDefault();
                    } else if (e.key === 'Escape') {
                        stopEditing(node, node.text);
                        e.preventDefault();
                    }
                    e.stopPropagation();
                };
                input.onblur = () => stopEditing(node, input.value);
                
                // Replace the content wrapper with input
                contentWrapper.innerHTML = '';
                contentWrapper.appendChild(input);
                input.focus();
                input.select();
            }
        }
        
        function stopEditing(node, value) {
            const oldText = node.text;
            node.text = value.trim() || 'New Item';
            editingNode = null;

            // Mark as changed if text actually changed
            if (oldText !== node.text) {
                markAsChanged();
            }

            // Don't re-render, just update the node in place
            if (node.element) {
                node.element.classList.remove('editing');

                // Clear all content first
                node.element.innerHTML = '';

                // Re-add checkbox
                const checkbox = document.createElement('div');
                checkbox.className = 'node-checkbox';
                if (node.completed) checkbox.classList.add('checked');
                checkbox.onclick = e => {
                    e.stopPropagation();
                    toggleNodeCompletion(node);
                };
                node.element.appendChild(checkbox);

                // Re-add content wrapper with updated text
                const contentWrapper = document.createElement('span');
                contentWrapper.className = 'node-content';
                contentWrapper.textContent = node.text;
                node.element.appendChild(contentWrapper);

                // Update completed state
                if (node.completed) {
                    node.element.classList.add('completed');
                } else {
                    node.element.classList.remove('completed');
                }

                // Re-apply status styling
                if (node.status && statusConfig[node.status]) {
                    node.element.classList.add(`status-${node.status}`);
                }

                // Adjust width based on text length (account for checkbox width)
                const textLength = node.text.length;
                if (textLength > 12) {
                    node.element.style.width = Math.min(200, Math.max(140, textLength * 8 + 32)) + 'px';
                } else {
                    node.element.style.width = '140px';
                }

                // Re-add expand button if needed
                if (node.children.length > 0) {
                    const btn = document.createElement('button');
                    btn.className = 'expand-btn';
                    btn.textContent = node.collapsed ? '+' : '−';
                    btn.onclick = e => {
                        e.stopPropagation();
                        toggleCollapse(node);
                    };
                    node.element.appendChild(btn);
                    node.expandBtn = btn;
                }

                // Re-add note indicator - only show when note exists
                if (node.note && node.note.trim()) {
                    const noteIndicator = document.createElement('div');
                    noteIndicator.className = 'note-indicator has-note';
                    noteIndicator.innerHTML = '📝';
                    // Show note text in tooltip, truncate if too long
                    const notePreview = node.note.length > 100 ? node.note.substring(0, 100) + '...' : node.note;
                    noteIndicator.title = `Note: ${notePreview}\n\nClick to edit`;
                    noteIndicator.onclick = e => {
                        e.stopPropagation();
                        openNoteModal(node);
                    };
                    node.element.appendChild(noteIndicator);
                }

                // Re-add status icon or placeholder
                if (node.status && statusConfig[node.status]) {
                    // Add status icon
                    const statusIcon = createStatusIcon(node);
                    node.element.appendChild(statusIcon);
                } else {
                    // Add status placeholder
                    const statusPlaceholder = createStatusPlaceholder(node);
                    node.element.appendChild(statusPlaceholder);
                }

                // Re-add hover controls
                addHoverControls(node.element, node);
            }
        }        // --- Expand/collapse ---
        function toggleCollapse(node) {
            node.collapsed = !node.collapsed;
            // Update button without re-rendering
            if (node.expandBtn) {
                node.expandBtn.textContent = node.collapsed ? '+' : '−';
            }

            // Hide/show children without full re-render
            if (node.collapsed) {
                // Hide all descendants
                hideDescendants(node);
            } else {
                // Show immediate children (they might have their own collapsed state)
                showChildren(node);
            }              
            
            // Rearrange positions and redraw edges with reduced spacing
            const roots = nodes.filter(n => !n.parent);
            const leftMargin = 200; // Use consistent left margin
            let currentY = 40; // Reduced margin from top
            
            roots.forEach(root => {
                const subtreeHeight = measureSubtreeHeight(root);
                arrangeSubtree(root, leftMargin, currentY + subtreeHeight / 2, 0);
                currentY += subtreeHeight + 50; // Reduced spacing between root trees
            });

            // Use efficient update to prevent flickering
            updatePositionsAndEdges();
        }

        function hideDescendants(node) {
            node.children.forEach(child => {
                if (child.element) {
                    child.element.style.display = 'none';
                }
                hideDescendants(child);
            });
        }

        function showChildren(node) {
            node.children.forEach(child => {
                if (child.element) {
                    child.element.style.display = 'flex';
                }
                if (!child.collapsed) {
                    showChildren(child);
                }
            });
        }        // --- Delete functionality ---
        function deleteNode(node) {
            if (!node) return;

            // Always show confirmation dialog for all nodes
            nodeToDelete = node;
            const childCount = countAllDescendants(node);

            // Update the confirmation message based on whether there are children
            const confirmDialog = document.getElementById('delete-confirm');
            const messageElement = confirmDialog.querySelector('p');

            if (node.children.length > 0) {
                messageElement.innerHTML = `This item has <span id="child-count">${childCount}</span> child item(s). Delete the entire branch?`;
            } else {
                messageElement.textContent = 'Are you sure you want to delete this item?';
            }

            document.getElementById('overlay').classList.remove('hidden');
            document.getElementById('delete-confirm').classList.remove('hidden');

            // Focus on cancel button for better accessibility
            setTimeout(() => {
                const cancelBtn = document.querySelector('.delete-confirm .cancel-btn');
                if (cancelBtn) cancelBtn.focus();
            }, 10);
        }

        function countAllDescendants(node) {
            let count = node.children.length;
            node.children.forEach(child => {
                count += countAllDescendants(child);
            });
            return count;
        }
        
        function performDelete(node) {
            markAsChanged(); // Mark as changed when deleting nodes
            
            // Select another node before deletion
            let newSelection = null;
            if (node.parent) {
                const siblings = node.parent.children;
                const index = siblings.indexOf(node);
                if (index > 0) {
                    newSelection = siblings[index - 1];
                } else if (index < siblings.length - 1) {
                    newSelection = siblings[index + 1];
                } else {
                    newSelection = node.parent;
                }
            } else {
                // Deleting root, select another root if available
                const roots = nodes.filter(n => !n.parent);
                const rootIndex = roots.indexOf(node);
                if (roots.length > 1) {
                    newSelection = roots[rootIndex === 0 ? 1 : 0];
                }
            }

            // Remove from parent's children
            if (node.parent) {
                const index = node.parent.children.indexOf(node);
                if (index > -1) {
                    node.parent.children.splice(index, 1);
                }

                // Remove expand button if parent now has no children
                if (node.parent.children.length === 0 && node.parent.expandBtn) {
                    node.parent.expandBtn.remove();
                    node.parent.expandBtn = null;
                }
            }            // Remove node and all descendants from nodes array
            const toRemove = [node];
            const collectDescendants = (n) => {
                n.children.forEach(child => {
                    toRemove.push(child);
                    collectDescendants(child);
                });
            };
            collectDescendants(node);
            // Remove DOM elements immediately
            toRemove.forEach(n => {
                if (n.element) {
                    n.element.remove();
                    n.element = null;
                }
                const index = nodes.indexOf(n);
                if (index > -1) {
                    nodes.splice(index, 1);
                }
            });

            // Clear all edges before rearranging to avoid orphaned edges
            const edges = canvas.querySelectorAll('.edge');
            edges.forEach(edge => edge.remove());

            // Select new node
            if (newSelection) {
                selectNode(newSelection);
            } else {
                selectedNode = null;
            }

            // Re-arrange and render
            autoArrange();
        }

        function confirmDelete() {
            if (nodeToDelete) {
                performDelete(nodeToDelete);
                cancelDelete();
            }
        }

        function cancelDelete() {
            nodeToDelete = null;
            document.getElementById('overlay').classList.add('hidden');
            document.getElementById('delete-confirm').classList.add('hidden');
        }

        // --- Context Menu functionality ---
        let contextMenu = null;

        function showContextMenu(e, node) {
            // Remove existing context menu if any
            hideContextMenu();

            // Create context menu
            contextMenu = document.createElement('div');
            contextMenu.className = 'context-menu';

            // Add rename option
            const renameItem = document.createElement('div');
            renameItem.className = 'context-menu-item';
            renameItem.innerHTML = '✏️ Rename';
            renameItem.onclick = () => {
                hideContextMenu();
                selectNode(node);
                startEditing(node);
            };
            contextMenu.appendChild(renameItem);

            // Add note option (only show if node doesn't have a note)
            if (!node.note || !node.note.trim()) {
                const addNoteItem = document.createElement('div');
                addNoteItem.className = 'context-menu-item';
                addNoteItem.innerHTML = '📝 Add note';
                addNoteItem.onclick = () => {
                    hideContextMenu();
                    openNoteModal(node);
                };
                contextMenu.appendChild(addNoteItem);
            } else {
                const editNoteItem = document.createElement('div');
                editNoteItem.className = 'context-menu-item';
                editNoteItem.innerHTML = '📝 Edit note';
                editNoteItem.onclick = () => {
                    hideContextMenu();
                    openNoteModal(node);
                };
                contextMenu.appendChild(editNoteItem);
            }

            // Add separator
            const separator = document.createElement('div');
            separator.className = 'context-menu-separator';
            contextMenu.appendChild(separator);

            // Add delete option
            const deleteItem = document.createElement('div');
            deleteItem.className = 'context-menu-item delete';
            deleteItem.innerHTML = '🗑️ Delete';
            deleteItem.onclick = () => {
                hideContextMenu();
                deleteNode(node);
            };
            contextMenu.appendChild(deleteItem);

            // Position context menu
            document.body.appendChild(contextMenu);

            // Calculate position to keep menu within viewport
            const menuRect = contextMenu.getBoundingClientRect();
            let x = e.clientX;
            let y = e.clientY;

            if (x + menuRect.width > window.innerWidth) {
                x = window.innerWidth - menuRect.width - 10;
            }
            if (y + menuRect.height > window.innerHeight) {
                y = window.innerHeight - menuRect.height - 10;
            }

            contextMenu.style.left = x + 'px';
            contextMenu.style.top = y + 'px';
        }

        function hideContextMenu() {
            if (contextMenu) {
                contextMenu.remove();
                contextMenu = null;
            }
        }

        // Hide context menu when clicking elsewhere
        document.addEventListener('click', hideContextMenu);
        document.addEventListener('contextmenu', (e) => {
            // Only prevent default context menu on nodes, allow it elsewhere
            if (!e.target.closest('.node')) {
                hideContextMenu();
            }
        });

        // --- Note functionality ---
        function openNoteModal(node) {
            currentNoteNode = node;
            const modal = document.getElementById('note-modal');
            const textarea = document.getElementById('note-textarea');
            const deleteBtn = document.getElementById('note-delete-btn');

            textarea.value = node.note || '';

            // Show/hide delete button based on whether note exists
            if (node.note && node.note.trim()) {
                deleteBtn.style.display = 'inline-block';
            } else {
                deleteBtn.style.display = 'none';
            }

            modal.classList.remove('hidden');
            document.getElementById('overlay').classList.remove('hidden');

            // Add keyboard handler for the textarea
            textarea.onkeydown = (e) => {
                if (e.key === 'Escape') {
                    closeNoteModal();
                    e.preventDefault();
                } else if (e.ctrlKey && e.key === 'Enter') {
                    saveNote();
                    e.preventDefault();
                } else if (e.altKey && e.key === 't') {
                    // Insert current date/time at cursor position
                    e.preventDefault();
                    const timestamp = generateTimestamp();
                    
                    const start = textarea.selectionStart;
                    const end = textarea.selectionEnd;
                    const text = textarea.value;
                    
                    textarea.value = text.substring(0, start) + timestamp + text.substring(end);
                    
                    // Place cursor after the inserted timestamp
                    const newPosition = start + timestamp.length;
                    textarea.setSelectionRange(newPosition, newPosition);
                }
                e.stopPropagation();
            };

            setTimeout(() => {
                textarea.focus();
                // Place cursor at the end instead of selecting all text
                const length = textarea.value.length;
                textarea.setSelectionRange(length, length);
            }, 100);
        } function closeNoteModal() {
            const modal = document.getElementById('note-modal');
            const textarea = document.getElementById('note-textarea');
            modal.classList.add('hidden');
            document.getElementById('overlay').classList.add('hidden');

            // Remove the keyboard handler
            textarea.onkeydown = null;
            currentNoteNode = null;
        }
        
        function saveNote() {
            if (currentNoteNode) {
                const textarea = document.getElementById('note-textarea');
                const oldNote = currentNoteNode.note;
                currentNoteNode.note = textarea.value.trim();
                
                // Mark as changed if note actually changed
                if (oldNote !== currentNoteNode.note) {
                    markAsChanged();
                }
                
                render();  // Re-render to update note indicators
                closeNoteModal();
            }
        }
        
        function deleteNote() {
            if (currentNoteNode) {
                // Disable note modal interaction
                document.getElementById('note-modal').classList.add('disabled');
                
                // Show confirmation dialog
                document.getElementById('overlay').classList.remove('hidden');
                document.getElementById('delete-note-confirm').classList.remove('hidden');
                
                // Focus on cancel button for better accessibility
                setTimeout(() => {
                    const cancelBtn = document.querySelector('#delete-note-confirm .cancel-btn');
                    if (cancelBtn) cancelBtn.focus();
                }, 10);
            }
        }
        
        function confirmDeleteNote() {
            if (currentNoteNode) {
                const oldNote = currentNoteNode.note;
                currentNoteNode.note = '';
                
                // Mark as changed if note was actually deleted
                if (oldNote) {
                    markAsChanged();
                }
                
                render();  // Re-render to update note indicators
                closeNoteModal();
            }
            
            // Re-enable note modal and hide confirmation dialog
            document.getElementById('note-modal').classList.remove('disabled');
            document.getElementById('overlay').classList.add('hidden');
            document.getElementById('delete-note-confirm').classList.add('hidden');
        }
        
        function cancelDeleteNote() {
            // Re-enable note modal and hide confirmation dialog
            document.getElementById('note-modal').classList.remove('disabled');
            document.getElementById('overlay').classList.add('hidden');
            document.getElementById('delete-note-confirm').classList.add('hidden');
        }
        
        // Make functions globally accessible for onclick handlers
        window.closeNoteModal = closeNoteModal;
        window.saveNote = saveNote;
        window.deleteNote = deleteNote;
        window.confirmDeleteNote = confirmDeleteNote;
        window.cancelDeleteNote = cancelDeleteNote;
        window.saveMindMapAsMarkdown = saveMindMapAsMarkdown;
        window.saveMindMapAsNewFile = saveMindMapAsNewFile; // Expose the new function
        window.loadMindMapFromMarkdown = loadMindMapFromMarkdown;
        window.toggleInstructions = toggleInstructions;
        window.cancelDelete = cancelDelete;
        window.confirmDelete = confirmDelete;
        window.toggleAutosave = toggleAutosave;
        window.clearRecentFiles = clearRecentFiles;
        window.closeFileReloadModal = closeFileReloadModal;
        window.selectFileToReload = selectFileToReload;

        let currentFileHandle = null; // Added to store the file handle for File System Access API
        let hasUnsavedChanges = false; // Track unsaved changes
        let currentFileName = null; // Track current file name
        let autosaveEnabled = true; // Enable autosave by default
        let autosaveTimeout = null; // Debounce timer for autosave

        // File status functions
        function updatePageTitle() {
            const baseTitle = 'Mind Map Editor';
            
            let title = '';
            if (currentFileName) {
                title = currentFileName;
                if (hasUnsavedChanges) {
                    title += '*';
                }
            } else {
                title = 'Untitled';
                if (hasUnsavedChanges) {
                    title += '*';
                }
            }
            
            // Use published timestamp if available (set by GitHub Action)
            const publishedTimestamp = typeof PUBLISHED_TIMESTAMP !== 'undefined' ? ` - Published ${PUBLISHED_TIMESTAMP}` : '';
            
            // Set the complete new title - PWA-friendly approach
            const newTitle = `${title} - ${baseTitle}${publishedTimestamp}`;
            
            // Multiple attempts to ensure title gets set in PWA environment
            document.title = newTitle;
            
            // Force title update with setTimeout for PWA compatibility
            setTimeout(() => {
                document.title = newTitle;
            }, 0);
            
            // Also try updating the title element directly
            const titleElement = document.querySelector('title');
            if (titleElement) {
                titleElement.textContent = newTitle;
            }
        }

        function updateFileStatus() {
            const fileStatusEl = document.getElementById('file-status');
            const fileNameEl = document.getElementById('file-name');
            const unsavedIndicatorEl = document.getElementById('unsaved-indicator');

            if (currentFileName) {
                fileStatusEl.classList.remove('no-file');
                fileNameEl.textContent = currentFileName;
                unsavedIndicatorEl.style.display = hasUnsavedChanges ? 'inline' : 'none';
            } else {
                fileStatusEl.classList.add('no-file');
                fileNameEl.textContent = 'Untitled';
                unsavedIndicatorEl.style.display = hasUnsavedChanges ? 'inline' : 'none';
            }
            
            // Update page title whenever file status changes
            updatePageTitle();
        }

        function markAsChanged() {
            if (!hasUnsavedChanges) {
                hasUnsavedChanges = true;
                updateFileStatus();
            }
            
            // Trigger autosave with debouncing
            if (autosaveEnabled && (currentFileHandle || currentFileName)) {
                clearTimeout(autosaveTimeout);
                autosaveTimeout = setTimeout(() => {
                    performAutosave();
                }, 2000); // Wait 2 seconds after last change before autosaving
            }
        }

        function markAsSaved() {
            hasUnsavedChanges = false;
            updateFileStatus();
        }

        function setCurrentFile(fileName) {
            currentFileName = fileName;
            hasUnsavedChanges = false;
            updateFileStatus();
            
            // Add filename to localStorage for auto-reload
            addFileToRecentList(fileName);
        }

        // Simple filename tracking for auto-reload
        function addFileToRecentList(fileName) {
            if (!fileName) return;
            
            try {
                let recentFiles = JSON.parse(localStorage.getItem('mindmap_recent_files') || '[]');
                
                // Remove if already exists (to move to front)
                recentFiles = recentFiles.filter(f => f !== fileName);
                
                // Add to front
                recentFiles.unshift(fileName);
                
                // Keep only last 10 files
                recentFiles = recentFiles.slice(0, 10);
                
                localStorage.setItem('mindmap_recent_files', JSON.stringify(recentFiles));
            } catch (error) {
                console.warn('Failed to save recent file to localStorage:', error);
            }
        }

        function getRecentFiles() {
            try {
                return JSON.parse(localStorage.getItem('mindmap_recent_files') || '[]');
            } catch (error) {
                console.warn('Failed to load recent files from localStorage:', error);
                return [];
            }
        }

        function clearRecentFiles() {
            try {
                localStorage.removeItem('mindmap_recent_files');
                showAutosaveNotification('Recent files cleared', false, true);
            } catch (error) {
                console.warn('Failed to clear recent files:', error);
            }
        }

        // Autosave functionality
        async function performAutosave() {
            if (!hasUnsavedChanges) return;
            
            // Show autosave in progress
            showAutosaveNotification('Autosaving...', false, false); // Don't auto-hide
            
            try {
                if (currentFileHandle) {
                    // Save using File System Access API
                    const markdown = generateMarkdown();
                    const writable = await currentFileHandle.createWritable();
                    await writable.write(markdown);
                    await writable.close();
                    markAsSaved();
                    showAutosaveNotification('Autosaved', false, true); // Auto-hide after delay
                } else if (currentFileName) {
                    // Fallback to download for browsers without File System Access API
                    const markdown = generateMarkdown();
                    const blob = new Blob([markdown], { type: 'text/markdown' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = currentFileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    markAsSaved();
                    showAutosaveNotification('Autosaved (downloaded)', false, true);
                }
            } catch (error) {
                console.error('Autosave failed:', error);
                showAutosaveNotification('Autosave failed: ' + error.message, true, true);
            }
        }

        function showAutosaveNotification(message, isError = false, autoHide = true) {
            let notification = document.getElementById('autosave-notification');
            if (!notification) {
                notification = document.createElement('div');
                notification.id = 'autosave-notification';
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 8px 16px;
                    border-radius: 4px;
                    color: white;
                    font-size: 14px;
                    z-index: 10000;
                    transition: opacity 0.3s ease;
                    opacity: 0;
                    pointer-events: none;
                    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
                `;
                document.body.appendChild(notification);
            }
            
            notification.textContent = message;
            notification.style.backgroundColor = isError ? '#e53e3e' : (message.includes('Autosaving') ? '#3182ce' : '#38a169');
            notification.style.opacity = '1';
            
            // Clear any existing timeout
            if (notification.timeoutId) {
                clearTimeout(notification.timeoutId);
            }
            
            if (autoHide) {
                notification.timeoutId = setTimeout(() => {
                    notification.style.opacity = '0';
                }, message.includes('Autosaved') ? 1500 : 3000); // Shorter for success, longer for errors
            }
        }

        function generateMarkdown() {
            const roots = nodes.filter(n => !n.parent);
            let markdown = '# Mind Map\n\n';
            
            roots.forEach(root => {
                markdown += nodeToMarkdown(root, 0);
            });
            
            return markdown;
        }

        function toggleAutosave() {
            autosaveEnabled = !autosaveEnabled;
            const button = document.getElementById('autosave-toggle');
            if (button) {
                button.textContent = `🔄 Autosave: ${autosaveEnabled ? 'ON' : 'OFF'}`;
                button.style.opacity = autosaveEnabled ? '1' : '0.6';
            }
            
            // Clear any pending autosave if disabled
            if (!autosaveEnabled && autosaveTimeout) {
                clearTimeout(autosaveTimeout);
                autosaveTimeout = null;
            }
            
            showAutosaveNotification(`Autosave ${autosaveEnabled ? 'enabled' : 'disabled'}`);
        }

        // File reload modal functions
        function showFileReloadModal() {
            const recentFiles = getRecentFiles();
            if (recentFiles.length === 0) return false;

            const modal = document.getElementById('file-reload-modal');
            const filesList = document.getElementById('recent-files-list');
            
            // Clear existing list
            filesList.innerHTML = '';
            
            // Add each recent file
            recentFiles.forEach((fileName, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.onclick = () => selectFileToReload(fileName);
                
                fileItem.innerHTML = `
                    <span class="file-icon">📄</span>
                    <span class="file-name">${fileName}</span>
                    <span class="file-action">Click to load</span>
                `;
                
                filesList.appendChild(fileItem);
            });
            
            modal.classList.remove('hidden');
            document.getElementById('overlay').classList.remove('hidden');
            return true;
        }

        function closeFileReloadModal() {
            const modal = document.getElementById('file-reload-modal');
            modal.classList.add('hidden');
            document.getElementById('overlay').classList.add('hidden');
        }

        async function selectFileToReload(fileName) {
            closeFileReloadModal();
            
            // Show notification about which file to select
            showAutosaveNotification(`Please select: ${fileName}`, false, true);
            
            // Just call the regular load function - user will select the file
            loadMindMapFromMarkdown();
        }

        // Auto-reload check on page load
        function checkForAutoReload() {
            // Only show auto-reload modal if:
            // 1. There are no existing nodes (fresh start)
            // 2. There are recent files available
            // 3. No file is currently loaded
            if (nodes.length === 0 && !currentFileName) {
                const recentFiles = getRecentFiles();
                if (recentFiles.length > 0) {
                    // Small delay to ensure DOM is ready
                    setTimeout(() => {
                        showFileReloadModal();
                    }, 500);
                }
            }
        }

// --- Keyboard controls ---
        document.addEventListener('keydown', e => {
            // Handle keyboard status picker (has its own event handler)
            if (document.getElementById('keyboard-status-picker')) {
                return; // Status picker keyboard handler will take care of this
            }

            // Handle escape key for note modal
            if (!document.getElementById('note-modal').classList.contains('hidden')) {
                if (e.key === 'Escape') {
                    closeNoteModal();
                    e.preventDefault();
                }
                return; // Don't process other keys when note modal is open
            }

            // Handle escape key for delete confirmation
            if (!document.getElementById('delete-confirm').classList.contains('hidden')) {
                if (e.key === 'Escape') {
                    cancelDelete();
                    e.preventDefault();
                }
                return; // Don't process other keys when dialog is open
            }

            // Handle escape key for note delete confirmation
            if (!document.getElementById('delete-note-confirm').classList.contains('hidden')) {
                if (e.key === 'Escape') {
                    cancelDeleteNote();
                    e.preventDefault();
                }
                return; // Don't process other keys when dialog is open
            }

            // Handle Ctrl+S for saving
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                saveMindMapAsMarkdown();
                return;
            }

            if (nodes.length === 0 && e.key === 'Enter') {
                createFirstNode({ clientX: window.innerWidth / 2, clientY: window.innerHeight / 2 });
                return;
            }
            if (!selectedNode) return;

            // Editing - only handle if selected
            if (e.key === 'Enter' && !e.ctrlKey) {
                if (editingNode === selectedNode) {
                    // If already editing, Enter will be handled by input's keydown
                    return;
                } else {
                    startEditing(selectedNode);
                    e.preventDefault();
                    return;
                }
            }

            // Don't handle other keys while editing
            if (editingNode) return;            // Delete key
            if (e.key === 'Delete') {
                if (selectedNode) {
                    deleteNode(selectedNode);
                    e.preventDefault();
                }
                return;
            }            // Note key (N)
            if (e.key === 'n' || e.key === 'N') {
                if (selectedNode) {
                    openNoteModal(selectedNode);
                    e.preventDefault();
                }
                return;
            }

            // Status key (S)
            if (e.key === 's' || e.key === 'S') {
                if (selectedNode) {
                    showKeyboardStatusPicker(selectedNode);
                    e.preventDefault();
                }
                return;
            }

            // Checkbox toggle key (Space)
            if (e.key === ' ') {
                if (selectedNode) {
                    toggleNodeCompletion(selectedNode);
                    e.preventDefault();
                }
                return;
            }

            // Navigation
            if (!e.ctrlKey) {
                if (e.key === 'ArrowRight') {
                    // Go to nearest child
                    if (!selectedNode.collapsed && selectedNode.children.length > 0) {
                        // Find child closest to current Y position
                        let closestChild = selectedNode.children[0];
                        let minDistance = Math.abs(closestChild.y - selectedNode.y);

                        selectedNode.children.forEach(child => {
                            const distance = Math.abs(child.y - selectedNode.y);
                            if (distance < minDistance) {
                                minDistance = distance;
                                closestChild = child;
                            }
                        });
                        selectNode(closestChild);
                    }
                } else if (e.key === 'ArrowLeft') {
                    // Always go to parent
                    if (selectedNode.parent) selectNode(selectedNode.parent);
                } else if (e.key === 'ArrowUp') {
                    // Strictly vertical up - find node directly above
                    const targetNode = findNodeVertically(selectedNode, 'up');
                    if (targetNode) selectNode(targetNode);
                } else if (e.key === 'ArrowDown') {
                    // Strictly vertical down - find node directly below
                    const targetNode = findNodeVertically(selectedNode, 'down');
                    if (targetNode) selectNode(targetNode);
                }
            }

            // Structure changes
            if (e.ctrlKey) {
                if (e.key === 'ArrowRight') {
                    if (selectedNode.collapsed) {
                        selectedNode.collapsed = false;
                        // Just update the button without full re-render
                        if (selectedNode.expandBtn) {
                            selectedNode.expandBtn.textContent = '−';
                        }
                        autoArrange();
                        // Focus on first child after expanding
                        if (selectedNode.children.length > 0) {
                            setTimeout(() => {
                                selectNode(selectedNode.children[0]);
                            }, 50);
                        }
                    } else {
                        createChildNode(selectedNode);
                    }
                    e.preventDefault();
                } else if (e.key === 'ArrowLeft') {
                    // Collapse current node if it has children, otherwise collapse parent
                    if (selectedNode.children.length > 0) {
                        // Current node has children
                        if (!selectedNode.collapsed) {
                            // Not collapsed - collapse it
                            selectedNode.collapsed = true;
                            // Update button without full re-render
                            if (selectedNode.expandBtn) {
                                selectedNode.expandBtn.textContent = '+';
                            }
                            // Hide descendants and update positions efficiently
                            hideDescendants(selectedNode);
                            autoArrange();
                        } else if (selectedNode.parent && selectedNode.parent.children.length > 0) {
                            // Already collapsed - collapse parent if it has children
                            if (!selectedNode.parent.collapsed) {
                                selectedNode.parent.collapsed = true;
                                selectNode(selectedNode.parent);
                                // Update button without full re-render
                                if (selectedNode.expandBtn) {
                                    selectedNode.expandBtn.textContent = '+';
                                }
                                hideDescendants(selectedNode);
                                autoArrange();
                            }
                        }
                    } else if (selectedNode.parent && selectedNode.parent.children.length > 0) {
                        // No children, but parent has children - collapse parent and select it
                        if (!selectedNode.parent.collapsed) {
                            selectedNode.parent.collapsed = true;
                            selectNode(selectedNode.parent);
                            // Update button without full re-render
                            if (selectedNode.expandBtn) {
                                selectedNode.expandBtn.textContent = '+';
                            }
                            hideDescendants(selectedNode);
                            autoArrange();
                        }
                    }
                    e.preventDefault();
                } else if (e.key === 'ArrowDown') {
                    if (selectedNode.parent) {
                        createSiblingNode(selectedNode, 1);
                    }
                    e.preventDefault();
                } else if (e.key === 'ArrowUp') {
                    if (selectedNode.parent) {
                        createSiblingNode(selectedNode, 0);
                    }
                    e.preventDefault();
                }
            }
        }, true); // MODIFIED: Added true for capturing phase to handle Ctrl+S during input focus

        function getVisibleSiblings(node) {
            if (!node.parent) return [node];
            return node.parent.children;
        }

        function findNodeInDirection(fromNode, direction) {
            // Get all visible nodes
            const visibleNodes = [];
            nodes.forEach(node => {
                if (isNodeVisible(node)) {
                    visibleNodes.push(node);
                }
            });

            // Sort by Y position
            visibleNodes.sort((a, b) => a.y - b.y);

            // Find nodes in the target direction
            const currentY = fromNode.y;
            const currentX = fromNode.x;
            let candidates = [];

            if (direction === 'up') {
                candidates = visibleNodes.filter(n => n.y < currentY - 10);
                candidates.sort((a, b) => b.y - a.y); // Closest first
            } else {
                candidates = visibleNodes.filter(n => n.y > currentY + 10);
                candidates.sort((a, b) => a.y - b.y); // Closest first
            }

            // Find the best candidate (closest in X direction among the closest in Y)
            if (candidates.length > 0) {
                // Group by similar Y position (within 30px)
                const firstY = candidates[0].y;
                const similarY = candidates.filter(n => Math.abs(n.y - firstY) < 30);

                // Among those, find closest X
                similarY.sort((a, b) => Math.abs(a.x - currentX) - Math.abs(b.x - currentX));
                return similarY[0];
            }

            return null;
        }

        function findNodeVertically(fromNode, direction) {
            // Get all visible nodes at the same generation level (siblings and cousins)
            const visibleNodes = [];
            const fromLevel = getNodeLevel(fromNode);

            nodes.forEach(node => {
                if (isNodeVisible(node) && node !== fromNode && getNodeLevel(node) === fromLevel) {
                    visibleNodes.push(node);
                }
            });

            const currentY = fromNode.y;

            // Filter nodes in the target direction
            let candidates = [];
            if (direction === 'up') {
                candidates = visibleNodes.filter(n => n.y < currentY);
                candidates.sort((a, b) => b.y - a.y); // Sort by Y descending (closest first)
            } else {
                candidates = visibleNodes.filter(n => n.y > currentY);
                candidates.sort((a, b) => a.y - b.y); // Sort by Y ascending (closest first)
            }

            // Return the closest node vertically
            if (candidates.length > 0) {
                return candidates[0];
            }

            return null;
        }

        function getNodeLevel(node) {
            let level = 0;
            let current = node;
            while (current.parent) {
                level++;
                current = current.parent;
            }
            return level;
        }

        function createChildNode(parent) {
            if (parent.collapsed) {
                parent.collapsed = false;
                // Update button without re-rendering
                if (parent.expandBtn) {
                    parent.expandBtn.textContent = '−';
                }
            }
            const node = createNode('New Item', 0, 0, parent);

            // If parent didn't have children before, it needs an expand button now
            if (parent.children.length === 1 && parent.element && !parent.expandBtn) {
                const btn = document.createElement('button');
                btn.className = 'expand-btn';
                btn.textContent = '−';
                btn.onclick = e => {
                    e.stopPropagation();
                    toggleCollapse(parent);
                };
                parent.element.appendChild(btn);
                parent.expandBtn = btn;
            }            // Efficient incremental update after adding child
            autoArrange();
            // Render the newly created child node
            renderSubtree(node);
            // Draw the edge connecting parent to the new node
            drawEdge(parent, node);
            // Smoothly update positions and edges
            updatePositionsAndEdges();
            // Select and start editing after positions update
            setTimeout(() => {
                selectNode(node);
                startEditing(node);
            }, 50);
        }

        function createSiblingNode(node, below = 1) {
            if (!node.parent) return;
            const parent = node.parent;
            const idx = parent.children.indexOf(node);
            const newNode = createNode('New Item', 0, 0, parent);
            parent.children.splice(parent.children.indexOf(newNode), 1); // Remove from end
            parent.children.splice(idx + below, 0, newNode);            // Efficient incremental update after adding sibling
            autoArrange();
            // Render the newly created sibling node
            renderSubtree(newNode);
            // Draw the edge connecting parent to the new sibling
            drawEdge(parent, newNode);
            // Smoothly update positions and edges
            updatePositionsAndEdges();

            // Select and start editing after positions update
            setTimeout(() => {
                selectNode(newNode);
                startEditing(newNode);
            }, 50);
        }

        // --- Save/Load ---
        // Remove saveMindMap and loadMindMap functions

        // --- Markdown Save/Load ---
        async function saveMindMapAsMarkdown() {
            try {
                // Find root nodes
                const roots = nodes.filter(n => !n.parent);
                let markdown = '# Mind Map\n\n'; // Corrected: Use actual newline characters

                // Convert tree to markdown
                roots.forEach(root => {
                    markdown += nodeToMarkdown(root, 0);
                });

                if (!window.showSaveFilePicker) {
                    alert('File System Access API is not supported in this browser. Falling back to download.');
                    // Fallback to old method
                    const blob = new Blob([markdown], { type: 'text/markdown' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = currentFileName || 'mindmap.md';
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    // Set filename for status display
                    if (!currentFileName) {
                        setCurrentFile('mindmap.md');
                    } else {
                        markAsSaved();
                    }
                    showAutosaveNotification('Downloaded successfully');
                    return;
                }

                if (!currentFileHandle) {
                    currentFileHandle = await window.showSaveFilePicker({
                        suggestedName: currentFileName || 'mindmap.md',
                        types: [{
                            description: 'Markdown Files',
                            accept: { 'text/markdown': ['.md'] },
                        }],
                    });
                }                const writable = await currentFileHandle.createWritable();
                await writable.write(markdown);
                await writable.close();
                
                // Update file status after successful save
                if (currentFileHandle.name) {
                    setCurrentFile(currentFileHandle.name);
                } else {
                    markAsSaved();
                }
                
                showAutosaveNotification('Saved successfully'); // Use autosave notification
            } catch (err) {
                if (err.name === 'AbortError') {
                    // User cancelled the file picker
                    console.log('Save operation cancelled by user.');
                } else {
                    console.error('Error saving mind map:', err);
                    showAutosaveNotification('Save failed: ' + err.message, true);
                    // Invalidate the handle on other errors so the user is prompted again
                    currentFileHandle = null;
                }
            }
        }        async function saveMindMapAsNewFile() {
            const oldFileHandle = currentFileHandle; // Temporarily store the old handle
            currentFileHandle = null; // Force showSaveFilePicker to always ask for a new file
            try {
                await saveMindMapAsMarkdown(); // This will now prompt for a new file location
                // If we reach here, save was successful, so don't restore old handle
            } catch (err) {
                // If saveMindMapAsMarkdown fails (e.g., user cancels), restore the old handle
                currentFileHandle = oldFileHandle;
                // Error is already handled and logged by saveMindMapAsMarkdown, so just rethrow or log here if needed
                console.error('Error during "Save As":', err);
                // Potentially alert the user if saveMindMapAsMarkdown doesn't already
            }
            
            // If currentFileHandle is still null after saveMindMapAsMarkdown (user cancelled),
            // restore the old handle
            if (currentFileHandle === null) {
                currentFileHandle = oldFileHandle;
            }
        }

        function nodeToMarkdown(node, level) {
            let markdown = '';
            const indent = '  '.repeat(level);
            const checkbox = node.completed ? '[x]' : '[ ]';
            
            // Include status icon in the text if status is set
            let nodeText = node.text;
            if (node.status && statusConfig[node.status]) {
                nodeText = statusConfig[node.status].icon + ' ' + nodeText;
            }
            
            markdown += indent + '- ' + checkbox + ' ' + nodeText + '\n';

            // Add note if it exists
            if (node.note && node.note.trim()) {
                const noteLines = node.note.trim().split('\n');
                noteLines.forEach(line => {
                    markdown += indent + '  > ' + line + '\n';
                });
            }

            // Add status metadata if status is set (as a comment for preservation)
            if (node.status) {
                markdown += indent + '  <!-- status:' + node.status + ' -->\n';
            }

            // Always include children regardless of collapsed state
            node.children.forEach(child => {
                markdown += nodeToMarkdown(child, level + 1);
            });

            return markdown;
        }

        async function loadMindMapFromMarkdown() { // Changed to async function
            if (window.showOpenFilePicker) {
                try {
                    const [fileHandle] = await window.showOpenFilePicker({
                        types: [{
                            description: 'Markdown Files',
                            accept: { 'text/markdown': ['.md', '.markdown'] },
                        }],
                        multiple: false,
                    });
                    const file = await fileHandle.getFile();
                    const markdown = await file.text();
                    console.log('Loading markdown file (via File System Access API)...', markdown.substring(0, 200) + '...');                    parseMarkdownToMindMap(markdown);
                    currentFileHandle = fileHandle; // Store the handle for future saves
                    
                    // Update file status after successful load
                    setCurrentFile(fileHandle.name);
                    
                    console.log('Loaded', nodes.length, 'nodes. File handle stored.');
                } catch (err) {
                    if (err.name === 'AbortError') {
                        console.log('File open operation cancelled by user.');
                    } else {
                        console.error('Error loading markdown via File System Access API:', err);
                        alert('Error loading markdown: ' + err.message);
                    }
                }
            } else {
                // Fallback to input element if File System Access API is not supported
                alert('File System Access API is not supported for opening. Falling back to standard file input.');
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.md,.markdown';
                input.onchange = e => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = re => {
                            try {
                                console.log('Loading markdown file (via input)...', re.target.result.substring(0, 200) + '...');                                parseMarkdownToMindMap(re.target.result);
                                currentFileHandle = null; // Ensure handle is cleared if using fallback
                                
                                // Update file status for fallback load (no file handle)
                                setCurrentFile(file.name);
                                
                                console.log('Loaded', nodes.length, 'nodes');
                            } catch (err) {
                                console.error('Error loading markdown:', err);
                                alert('Error loading markdown: ' + err.message);
                            }
                        };
                        reader.readAsText(file);
                    }
                };
                input.click();
            }
        }
        
        function parseMarkdownToMindMap(markdown) {
            console.log('Parsing markdown:', markdown.substring(0, 100) + '...');
            
            // Clear any pending autosave timer
            if (autosaveTimeout) {
                clearTimeout(autosaveTimeout);
                autosaveTimeout = null;
            }
            
            // Clear existing DOM elements before clearing the nodes array
            nodes.forEach(node => {
                if (node.element) {
                    node.element.remove();
                    node.element = null;
                }
            });
            
            // Clear all edges from the canvas
            const edges = canvas.querySelectorAll('.edge');
            edges.forEach(edge => edge.remove());
            
            nodes = [];
            selectedNode = null;
            nextId = 1;

            // Extract metadata and collapsed state - removed per user request
            // Parse markdown lines - handle both CRLF and LF line endings
            const lines = markdown.replace(/\r\n/g, '\n').split('\n');
            const nodeStack = [];
            let currentNode = null;
            lines.forEach(line => {
                // Skip empty lines and metadata
                if (!line.trim() || line.startsWith('#')) return;
                
                // Check for status metadata comments
                const statusMatch = line.match(/^(\s*)<!--\s*status:(\w+)\s*-->$/);
                if (statusMatch) {
                    const indent = statusMatch[1].length / 2;
                    const statusKey = statusMatch[2];
                    
                    // Find the node this status belongs to based on indentation
                    let targetNode = null;
                    if (indent === 0) {
                        // Status at root level - find the last root node
                        for (let i = nodes.length - 1; i >= 0; i--) {
                            if (!nodes[i].parent) {
                                targetNode = nodes[i];
                                break;
                            }
                        }
                    } else {
                        // Status is indented - find the node at the parent level
                        const parentLevel = indent - 1;
                        for (let i = nodeStack.length - 1; i >= 0; i--) {
                            if (nodeStack[i].level === parentLevel) {
                                targetNode = nodeStack[i].node;
                                break;
                            }
                        }
                    }
                    
                    if (targetNode && statusConfig[statusKey]) {
                        targetNode.status = statusKey;
                        targetNode.statusIcon = statusConfig[statusKey].icon;
                        console.log('Applied status to:', targetNode.text, 'status:', statusKey);
                    }
                    return;
                }

                console.log('Processing line:', line);
                // Check if this is a note line (indented >)
                const noteMatch = line.match(/^(\s*)>\s*(.*)$/);
                if (noteMatch) {
                    const noteIndent = noteMatch[1].length / 2;
                    const noteText = noteMatch[2];

                    // Find the node this note belongs to based on indentation
                    let targetNode = null;
                    if (noteIndent === 0) {
                        // Note at root level - find the last root node
                        for (let i = nodes.length - 1; i >= 0; i--) {
                            if (!nodes[i].parent) {
                                targetNode = nodes[i];
                                break;
                            }
                        }
                    } else {
                        // Note is indented - find the node at the parent level
                        const parentLevel = noteIndent - 1;
                        for (let i = nodeStack.length - 1; i >= 0; i--) {
                            if (nodeStack[i].level === parentLevel) {
                                targetNode = nodeStack[i].node;
                                break;
                            }
                        }
                    }

                    if (targetNode) {
                        if (targetNode.note) {
                            targetNode.note += '\n' + noteText;
                        } else {
                            targetNode.note = noteText;
                        }
                        console.log('Added note to:', targetNode.text, 'note:', noteText);
                    } else {
                        console.warn('Could not find target node for note:', noteText, 'at indent:', noteIndent);
                    }
                    return;
                }

                // Count indentation (2 spaces per level)
                const indentMatch = line.match(/^(\s*)-\s*(\[[x\s]\])?\s*(.+)$/);
                if (indentMatch) {
                    const indent = indentMatch[1].length / 2;
                    const checkboxMatch = indentMatch[2];
                    let text = indentMatch[3].trim();
                    
                    // Extract status icon from text if present
                    let detectedStatus = '';
                    Object.entries(statusConfig).forEach(([key, config]) => {
                        if (text.startsWith(config.icon + ' ')) {
                            detectedStatus = key;
                            text = text.substring(config.icon.length + 1); // Remove icon and space
                        }
                    });
                    
                    // Determine completion status from checkbox
                    const completed = checkboxMatch && checkboxMatch.includes('x');
                    
                    // Find parent based on indentation
                    let parent = null;
                    if (indent > 0 && nodeStack.length > 0) {
                        // Find the most recent node at the parent level (indent - 1)
                        for (let i = nodeStack.length - 1; i >= 0; i--) {
                            if (nodeStack[i].level === indent - 1) {
                                parent = nodeStack[i].node;
                                break;
                            }
                        }
                    }
                    
                    // Create node
                    const node = createNode(text, 0, 0, parent);
                    node.completed = completed; // Set completion status
                    
                    // Set status if detected from icon
                    if (detectedStatus) {
                        node.status = detectedStatus;
                        node.statusIcon = statusConfig[detectedStatus].icon;
                    }
                    
                    currentNode = node;
                    
                    // Update stack - remove all nodes at same or deeper level first
                    while (nodeStack.length > 0 &&
                        nodeStack[nodeStack.length - 1].level >= indent) {
                        nodeStack.pop();
                    }

                    // Now add the current node
                    nodeStack.push({ node, level: indent });
                }
            });

            console.log('Finished parsing. Created', nodes.length, 'nodes');
            autoArrange(true); // Force full render since nodes don't have DOM elements yet
            if (nodes.length > 0) selectNode(nodes[0]);
        }

        // --- UI Functions ---
        function showSaveNotification(fileName) {
            const notification = document.getElementById('save-notification') || createSaveNotificationElement();
            notification.textContent = `Saved to ${fileName}`;
            notification.classList.add('show');

            // Hide after a few seconds
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000); // Adjust time as needed (3 seconds)
        }

        function createSaveNotificationElement() {
            const notification = document.createElement('div');
            notification.id = 'save-notification';
            document.body.appendChild(notification);
            return notification;
        }

        function toggleInstructions() {
            const instructions = document.getElementById('instructions');
            instructions.classList.toggle('collapsed');
            instructions.classList.toggle('expanded');
        }        // --- Initial ---
        canvasContainer.style.cursor = 'grab';
        window.addEventListener('resize', () => {
            autoArrange();
        });

        // Ensure modals are hidden on load
        document.getElementById('note-modal').classList.add('hidden');
        document.getElementById('overlay').classList.add('hidden');
        document.getElementById('delete-confirm').classList.add('hidden');
        document.getElementById('delete-note-confirm').classList.add('hidden');        // Initial render
        scheduleRender();
        
        // Initialize file status display and page title
        updateFileStatus();
        
        // Additional PWA title fix - ensure title is set after all resources load
        window.addEventListener('load', () => {
            setTimeout(() => {
                updatePageTitle();
            }, 100);
        });
        
        // Also handle document ready state changes for PWA compatibility
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(() => {
                    updatePageTitle();
                }, 50);
            });
        } else {
            // Document already loaded
            setTimeout(() => {
                updatePageTitle();
            }, 50);
        }
    </script>
</body>

</html>